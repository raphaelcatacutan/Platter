prod_no	<lhs>	=>	action_type	ast_class	field_mapping	note	
1	<program>	=>	create	Program	global_decl=collect($0) recipe_decl=collect($1) start_platter=$5	Root node	
2	<global_decl>	=>	collect	-	$1 + $2	Piece global var	
3	<global_decl>	=>	collect	-	$1 + $2	Chars global var	
4	<global_decl>	=>	collect	-	$1 + $2	Sip global var	
5	<global_decl>	=>	collect	-	$1 + $2	Flag global var	
6	<global_decl>	=>	collect	-	[$0] + $1	Table prototype	
7	<global_decl>	=>	collect	-	$1 + $2	Table instance	
8	<global_decl>	=>	collect	-	[]	Empty global decl	
9	<piece_decl>	=>	propagate	-	$1	Piece declaration	
10	<piece_decl>	=>	propagate	-	$0	Piece array declaration	
11	<piece_id>	=>	collect	-	[VarDecl("piece", $0.value, $1)] + $2	Piece var with init	
12	<piece_ingredient_init>	=>	propagate	-	$1	Has initializer	
13	<piece_ingredient_init>	=>	skip	-	-	No initializer	
14	<piece_id_tail>	=>	collect	-	[VarDecl("piece", $1.value, $2)] + $3	Piece var tail	
15	<piece_id_tail>	=>	collect	-	[]	No more piece vars	
16	<chars_decl>	=>	propagate	-	$1	Chars declaration	
17	<chars_decl>	=>	propagate	-	$0	Chars array declaration	
18	<chars_id>	=>	collect	-	[VarDecl("chars", $0.value, $1)] + $2	Chars var with init	
19	<chars_ingredient_init>	=>	propagate	-	$1	Has initializer	
20	<chars_ingredient_init>	=>	skip	-	-	No initializer	
21	<chars_id_tail>	=>	collect	-	[VarDecl("chars", $1.value, $2)] + $3	Chars var tail	
22	<chars_id_tail>	=>	collect	-	[]	No more chars vars	
23	<sip_decl>	=>	propagate	-	$1	Sip declaration	
24	<sip_decl>	=>	propagate	-	$0	Sip array declaration	
25	<sip_id>	=>	collect	-	[VarDecl("sip", $0.value, $1)] + $2	Sip var with init	
26	<sip_ingredient_init>	=>	propagate	-	$1	Has initializer	
27	<sip_ingredient_init>	=>	skip	-	-	No initializer	
28	<sip_id_tail>	=>	collect	-	[VarDecl("sip", $1.value, $2)] + $3	Sip var tail	
29	<sip_id_tail>	=>	collect	-	[]	No more sip vars	
30	<flag_decl>	=>	propagate	-	$1	Flag declaration	
31	<flag_decl>	=>	propagate	-	$0	Flag array declaration	
32	<flag_id>	=>	collect	-	[VarDecl("flag", $0.value, $1)] + $2	Flag var with init	
33	<flag_ingredient_init>	=>	propagate	-	$1	Has initializer	
34	<flag_ingredient_init>	=>	skip	-	-	No initializer	
35	<flag_id_tail>	=>	collect	-	[VarDecl("flag", $1.value, $2)] + $3	Flag var tail	
36	<flag_id_tail>	=>	collect	-	[]	No more flag vars	
37	<piece_array_decl>	=>	collect	-	[ArrayDecl("piece",$0,$2.value,$3)] + $4	Piece array decl	
38	<sip_array_decl>	=>	collect	-	[ArrayDecl("sip",$0,$2.value,$3)] + $4	Sip array decl	
39	<chars_array_decl>	=>	collect	-	[ArrayDecl("chars",$0,$2.value,$3)] + $4	Chars array decl	
40	<flag_array_decl>	=>	collect	-	[ArrayDecl("flag",$0,$2.value,$3)] + $4	Flag array decl	
41	<table_array_decl>	=>	collect	-	[ArrayDecl(CONTEXT_TYPE,$0,$2.value,$3)] + $4	Table array decl	
42	<piece_array_val>	=>	propagate	-	$0	Array val is ID	
43	<piece_array_val>	=>	propagate	-	$0	Array val is ret	
44	<piece_array_val>	=>	create	ArrayLiteral	elements=$1	Array literal	
45	<piece_array_init>	=>	propagate	-	$1	Has array init	
46	<piece_array_init>	=>	skip	-	-	No array init	
47	<sip_array_val>	=>	propagate	-	$0	Array val is ID	
48	<sip_array_val>	=>	propagate	-	$0	Array val is ret	
49	<sip_array_val>	=>	create	ArrayLiteral	elements=$1	Array literal	
50	<sip_array_init>	=>	propagate	-	$1	Has array init	
51	<sip_array_init>	=>	skip	-	-	No array init	
52	<chars_array_val>	=>	propagate	-	$0	Array val is ID	
53	<chars_array_val>	=>	propagate	-	$0	Array val is ret	
54	<chars_array_val>	=>	create	ArrayLiteral	elements=$1	Array literal	
55	<chars_array_init>	=>	propagate	-	$1	Has array init	
56	<chars_array_init>	=>	skip	-	-	No array init	
57	<flag_array_val>	=>	propagate	-	$0	Array val is ID	
58	<flag_array_val>	=>	propagate	-	$0	Array val is ret	
59	<flag_array_val>	=>	create	ArrayLiteral	elements=$1	Array literal	
60	<flag_array_init>	=>	propagate	-	$1	Has array init	
61	<flag_array_init>	=>	skip	-	-	No array init	
62	<table_array_val>	=>	propagate	-	$0	Array val is ID	
63	<table_array_val>	=>	propagate	-	$0	Array val is ret	
64	<table_array_val>	=>	create	ArrayLiteral	elements=$1	Array literal	
65	<table_array_init>	=>	propagate	-	$1	Has array init	
66	<table_array_init>	=>	skip	-	-	No array init	
67	<array_declare_tail_piece>	=>	collect	-	[ArrayDecl("piece",CONTEXT,$1.value,$2)] + $3	More piece array decls	
68	<array_declare_tail_piece>	=>	collect	-	[]	No more piece array decls	
69	<array_declare_tail_sip>	=>	collect	-	[ArrayDecl("sip",CONTEXT,$1.value,$2)] + $3	More sip array decls	
70	<array_declare_tail_sip>	=>	collect	-	[]	No more sip array decls	
71	<array_declare_tail_flag>	=>	collect	-	[ArrayDecl("flag",CONTEXT,$1.value,$2)] + $3	More flag array decls	
72	<array_declare_tail_flag>	=>	collect	-	[]	No more flag array decls	
73	<array_declare_tail_chars>	=>	collect	-	[ArrayDecl("chars",CONTEXT,$1.value,$2)] + $3	More chars array decls	
74	<array_declare_tail_chars>	=>	collect	-	[]	No more chars array decls	
75	<array_declare_tail_table>	=>	collect	-	[ArrayDecl(CONTEXT_TYPE,CONTEXT,$1.value,$2)] + $3	More table array decls	
76	<array_declare_tail_table>	=>	collect	-	[]	No more table array decls	
77	<dimensions>	=>	count_dims	-	base=1 tail=$2	Count dimensions	
78	<dimensions_tail>	=>	propagate	-	$0	More dimensions	
79	<dimensions_tail>	=>	skip	-	-	No more dimensions	
80	<flavor>	=>	collect	-	[$0] + $1	Arguments list	
81	<flavor>	=>	collect	-	[]	No arguments	
82	<value>	=>	propagate	-	$0	Value is any_expr	
83	<value>	=>	propagate	-	$0	Value is ret_array	
84	<value>	=>	propagate	-	$1	Value is array literal	
85	<notation_val>	=>	propagate	-	$0	Notation is element	
86	<notation_val>	=>	propagate	-	$1 context_id=$0.value	Notation is ID with tail	
87	<notation_val>	=>	skip	-	-	Empty notation	
88	<array_element>	=>	collect	-	[Literal("piece", $0.value)] + $1	Piece literal element	
89	<array_element>	=>	collect	-	[Literal("sip", $0.value)] + $1	Sip literal element	
90	<array_element>	=>	collect	-	[Literal("flag", $0.value)] + $1	Flag literal element	
91	<array_element>	=>	collect	-	[Literal("chars", $0.value)] + $1	Chars literal element	
92	<array_element>	=>	collect	-	[ArrayLiteral($1)] + $3	Nested array literal	
93	<element_value_tail>	=>	collect	-	$1	More elements	
94	<element_value_tail>	=>	collect	-	[]	No more elements	
95	<array_element_id>	=>	collect	-	[Identifier($0.value)] + $1	ID element	
96	<array_element_id>	=>	propagate	-	$0	Array element	
97	<array_element_id>	=>	collect	-	[]	Empty element list	
98	<array_element_piece>	=>	collect	-	[Identifier($0.value)] + $1	Piece array ID	
99	<array_element_piece>	=>	collect	-	[Literal("piece",$0.value)] + $1	Piece array lit	
100	<array_element_piece>	=>	collect	-	[ArrayLiteral($1)] + $3	Piece nested array	
101	<array_element_piece_opt>	=>	propagate	-	$0	Piece array elements	
102	<array_element_piece_opt>	=>	collect	-	[]	Empty piece array	
103	<element_piece_tail>	=>	collect	-	$1	More piece elements	
104	<element_piece_tail>	=>	collect	-	[]	No more piece elements	
105	<array_element_sip>	=>	collect	-	[Identifier($0.value)] + $1	Sip array ID	
106	<array_element_sip>	=>	collect	-	[Literal("sip",$0.value)] + $1	Sip array lit	
107	<array_element_sip>	=>	collect	-	[ArrayLiteral($1)] + $3	Sip nested array	
108	<array_element_sip_opt>	=>	propagate	-	$0	Sip array elements	
109	<array_element_sip_opt>	=>	collect	-	[]	Empty sip array	
110	<element_sip_tail>	=>	collect	-	$1	More sip elements	
111	<element_sip_tail>	=>	collect	-	[]	No more sip elements	
112	<array_element_chars>	=>	collect	-	[Identifier($0.value)] + $1	Chars array ID	
113	<array_element_chars>	=>	collect	-	[Literal("chars",$0.value)] + $1	Chars array lit	
114	<array_element_chars>	=>	collect	-	[ArrayLiteral($1)] + $3	Chars nested array	
115	<array_element_chars_opt>	=>	propagate	-	$0	Chars array elements	
116	<array_element_chars_opt>	=>	collect	-	[]	Empty chars array	
117	<element_chars_tail>	=>	collect	-	$1	More chars elements	
118	<element_chars_tail>	=>	collect	-	[]	No more chars elements	
119	<array_element_flag>	=>	collect	-	[Identifier($0.value)] + $1	Flag array ID	
120	<array_element_flag>	=>	collect	-	[Literal("flag",$0.value)] + $1	Flag array lit	
121	<array_element_flag>	=>	collect	-	[ArrayLiteral($1)] + $3	Flag nested array	
122	<array_element_flag_opt>	=>	propagate	-	$0	Flag array elements	
123	<array_element_flag_opt>	=>	collect	-	[]	Empty flag array	
124	<element_flag_tail>	=>	collect	-	$1	More flag elements	
125	<element_flag_tail>	=>	collect	-	[]	No more flag elements	
126	<array_element_table>	=>	collect	-	[$0] + $1	Table array element	
127	<array_element_table_opt>	=>	propagate	-	$0	Table array elements	
128	<array_element_table_opt>	=>	collect	-	[]	Empty table array	
129	<element_table_tail>	=>	collect	-	$1	More table elements	
130	<element_table_tail>	=>	collect	-	[]	No more table elements	
131	<array_or_table>	=>	collect	-	[Identifier(CONTEXT_ID)] + $1	Array continuation	
132	<array_or_table>	=>	collect	-	TableLiteral([(CONTEXT_ID,$1)] + $3)	Table literal	
133	<array_or_table>	=>	propagate	-	Identifier(CONTEXT_ID)	Identifier only	
134	<field_assignments>	=>	collect	-	[($0.value, $2)] + $4	Field assignment	
135	<field_assignments>	=>	collect	-	[]	No more fields	
136	<flavor_tail>	=>	collect	-	[$1] + $2	More arguments	
137	<flavor_tail>	=>	collect	-	[]	No more arguments	
138	<accessor_tail>	=>	propagate	-	$0	Array accessor	
139	<accessor_tail>	=>	propagate	-	$0	Table accessor	
140	<accessor_tail>	=>	skip	-	-	No accessor	
141	<array_accessor>	=>	build_access	-	type=array value=$1	Array access start	
142	<array_accessor_val>	=>	build_access	-	index=Literal("piece",$0.value) tail=$2	Piece lit index	
143	<array_accessor_val>	=>	build_access	-	index=Identifier($0.value) tail=$2	ID index	
144	<table_accessor>	=>	build_access	-	type=table field=$1.value tail=$2	Table field access	
145	<table_prototype>	=>	create	TablePrototype	name=$2.value fields=$5	Table type definition	
146	<required_decl>	=>	collect	-	[$0] + $2	Field declarations	
147	<decl_head>	=>	create	FieldDecl	data_type=$0_type dimensions=$0_dims identifier=$2.value	Field/param declaration	
148	<primitive_types_dims>	=>	propagate	-	type="piece" dims=$1	Piece type	
149	<primitive_types_dims>	=>	propagate	-	type="sip" dims=$1	Sip type	
150	<primitive_types_dims>	=>	propagate	-	type="flag" dims=$1	Flag type	
151	<primitive_types_dims>	=>	propagate	-	type="chars" dims=$1	Chars type	
152	<primitive_types_dims>	=>	propagate	-	type=$0.value dims=$1	Table/ID type	
153	<required_decl_tail>	=>	propagate	-	$0	More fields	
154	<required_decl_tail>	=>	collect	-	[]	No more fields	
155	<table_decl>	=>	propagate	-	$1	Table declaration	
156	<table_decl>	=>	propagate	-	$0	Table array declaration	
157	<table_declare>	=>	collect	-	[TableDecl(CONTEXT_TYPE,$0.value,$1)] + $2	Table instances	
158	<table_init>	=>	propagate	-	$1	Table init	
159	<table_init>	=>	skip	-	-	No table init	
160	<strict_table_expr>	=>	create	TableLiteral	field_inits=$1	Table literal	
161	<strict_table_expr>	=>	propagate	-	$0	Table expr is ID	
162	<table_declare_tail>	=>	collect	-	$1	More table decls	
163	<table_declare_tail>	=>	collect	-	[]	No more table decls	
164	<recipe_decl>	=>	collect	-	[RecipeDecl($1_data_type,$1_dimensions,$1_identifier,$3,$5)] + $6	Recipe declaration	
165	<recipe_decl>	=>	collect	-	[]	No more recipes	
166	<serve_type>	=>	propagate	-	$0	Return type	
167	<spice>	=>	collect	-	[$0] + $1	Parameters	
168	<spice>	=>	collect	-	[]	No parameters	
169	<spice_tail>	=>	collect	-	[$1] + $2	More parameters	
170	<spice_tail>	=>	collect	-	[]	No more parameters	
171	<platter>	=>	manual	-	(lambda decls, stmts: Platter([d for d in decls if isinstance(d, (VarDecl, ArrayDecl, TableDecl))], [s for s in decls if isinstance(s, (Assignment, ExpressionStatement, IfStatement, WhileLoop, ForLoop, DoWhileLoop, SwitchStatement, BreakStatement, ContinueStatement, ReturnStatement))] + stmts))($1, $2)	Block/compound statement	
172	<local_decl>	=>	collect	-	$1 + $2	Piece local decl	
173	<local_decl>	=>	collect	-	$1 + $2	Chars local decl	
174	<local_decl>	=>	collect	-	$1 + $2	Sip local decl	
175	<local_decl>	=>	collect	-	$1 + $2	Flag local decl	
176	<local_decl>	=>	collect	-	$1	Table local decl/statements	
177	<local_decl>	=>	collect	-	[]	No more local decl	
178	<local_id_tail>	=>	collect	-	[TableDecl(CONTEXT,$1)] + $3	Table local var	
179	<local_id_tail>	=>	collect	-	$1	Array local/stmt hybrid	
180	<local_id_tail>	=>	collect	-	[Assignment(($0(CONTEXT) if $0 else CONTEXT), $1, $2)] + $4	Local assignment with accessor	
181	<local_id_tail>	=>	collect	-	[Assignment(CONTEXT, $0, $1)] + $3	Local assignment	
182	<local_id_tail>	=>	collect	-	[ExpressionStatement($0)] + $2	Local call/tail	
183	<endsb_tail>	=>	collect	-	[ArrayDecl(CONTEXT,$1,$3.value,$4)] + $6	Array decl end bracket	
184	<endsb_tail>	=>	collect	-	[Assignment(($0(CONTEXT) if $0 else CONTEXT), $1, $2)] + $4	Array assignment end bracket	
185	<assignment_op>	=>	token	-	value==	=	
186	<assignment_op>	=>	token	-	value=+=	+=	
187	<assignment_op>	=>	token	-	value=-=	-=	
188	<assignment_op>	=>	token	-	value=*=	*=	
189	<assignment_op>	=>	token	-	value=/=	/=	
190	<assignment_op>	=>	token	-	value=%=	%=	
191	<statements>	=>	collect	-	$0 + $1	ID statement	
192	<statements>	=>	collect	-	[ExpressionStatement($0)] + $2	Built-in call statement	
193	<statements>	=>	collect	-	[$0] + $1	Conditional statement	
194	<statements>	=>	collect	-	[$0] + $1	Loop statement	
195	<statements>	=>	collect	-	[$0] + $1	Jump/return statement	
196	<statements>	=>	collect	-	[]	No more statements	
197	<id_statements>	=>	manual	-	(lambda ctx, stmt, rest: (setattr(self, '_context_identifier', ctx), stmt + rest)[1])($0.value, [$1], $2)	ID statement extension	
198	<id_statements_ext>	=>	create	ExpressionStatement	expr=$0	Function call statement	
199	<id_statements_ext>	=>	propagate	-	$0	Assignment statement	
200	<tail1>	=>	propagate	-	$0	Statement tail call	
201	<call_tail>	=>	create	FunctionCall	name=CONTEXT_ID args=$1	Statement call	
202	<assignment_st>	=>	create	Assignment	target=CONTEXT accessor=$0 operator=$1 value=$2	Assignment with accessor	
203	<built_in_rec_call>	=>	propagate	-	$0	Built-in call wrapper	
204	<built_in_rec>	=>	create	FunctionCall	name=append args=[$2,$4]	append()	
205	<built_in_rec>	=>	create	FunctionCall	name=bill args=[$2]	bill()	
206	<built_in_rec>	=>	create	FunctionCall	name=copy args=[$2,$4,$6]	copy()	
207	<built_in_rec>	=>	create	FunctionCall	name=cut args=[$2,$4]	cut()	
208	<built_in_rec>	=>	create	FunctionCall	name=fact args=[$2]	fact()	
209	<built_in_rec>	=>	create	FunctionCall	name=matches args=[$2,$4]	matches()	
210	<built_in_rec>	=>	create	FunctionCall	name=pow args=[$2,$4]	pow()	
211	<built_in_rec>	=>	create	FunctionCall	name=rand args=[]	rand()	
212	<built_in_rec>	=>	create	FunctionCall	name=remove args=[$2,$4]	remove()	
213	<built_in_rec>	=>	create	FunctionCall	name=reverse args=[$2]	reverse()	
214	<built_in_rec>	=>	create	FunctionCall	name=search args=[$2,$4]	search()	
215	<built_in_rec>	=>	create	FunctionCall	name=size args=[$2]	size()	
216	<built_in_rec>	=>	create	FunctionCall	name=sort args=[$2]	sort()	
217	<built_in_rec>	=>	create	FunctionCall	name=sqrt args=[$2]	sqrt()	
218	<built_in_rec>	=>	create	FunctionCall	name=take args=[]	take()	
219	<built_in_rec>	=>	create	FunctionCall	name=tochars args=[$2]	tochars()	
220	<built_in_rec>	=>	create	FunctionCall	name=topiece args=[$2]	topiece()	
221	<built_in_rec>	=>	create	FunctionCall	name=tosip args=[$2]	tosip()	
222	<conditional_st>	=>	propagate	-	$0	Cond check	
223	<conditional_st>	=>	propagate	-	$0	Cond menu	
224	<cond_check>	=>	create	IfStatement	condition=$2 then_block=$4 elif_clauses=$5 else_block=$6	If statement	
225	<alt_clause>	=>	collect	-	[($2,$4)] + $5	Elif clause	
226	<alt_clause>	=>	collect	-	[]	No elif	
227	<instead_clause>	=>	propagate	-	$1	Else block	
228	<instead_clause>	=>	skip	-	-	No else	
229	<cond_menu>	=>	create	SwitchStatement	expr=$2 cases=$4	Switch statement	
230	<menu_platter>	=>	collect	-	$1 + $2	Menu body	
231	<choice_clause>	=>	collect	-	[CaseClause($1,$3)] + $4	Case clause	
232	<choice_clause>	=>	collect	-	[]	No more cases	
233	<choice_val>	=>	create	Literal	value_type=piece value=$0.value	Piece case value	
234	<choice_val>	=>	create	Literal	value_type=chars value=$0.value	Chars case value	
235	<statements_menu>	=>	collect	-	[$0] + $1	Menu statement ID	
236	<statements_menu>	=>	collect	-	[ExpressionStatement($0)] + $2	Menu built-in	
237	<statements_menu>	=>	collect	-	[$0] + $1	Menu conditional	
238	<statements_menu>	=>	collect	-	[$0] + $1	Menu looping	
239	<statements_menu>	=>	collect	-	[$0] + $1	Menu jump stop	
240	<statements_menu>	=>	collect	-	[$0] + $1	Menu jump serve	
241	<statements_menu>	=>	collect	-	[]	No more menu stmts	
242	<id_statements_menu>	=>	propagate	-	$1	Menu ID stmt ext	
243	<conditional_st_menu>	=>	propagate	-	$0	Menu cond check	
244	<conditional_st_menu>	=>	propagate	-	$0	Menu cond menu	
245	<cond_check_menu>	=>	create	IfStatement	condition=$2 then_block=$4 elif_clauses=$5 else_block=$6	Menu if stmt	
246	<menu_check_platter>	=>	create	Platter	local_decls=$1 statements=$2	Menu check body	
247	<local_decl_menu>	=>	collect	-	$1 + $2	Menu piece decl	
248	<local_decl_menu>	=>	collect	-	$1 + $2	Menu chars decl	
249	<local_decl_menu>	=>	collect	-	$1 + $2	Menu sip decl	
250	<local_decl_menu>	=>	collect	-	$1 + $2	Menu flag decl	
251	<local_decl_menu>	=>	collect	-	$1	Menu table decl	
252	<local_decl_menu>	=>	collect	-	[]	No more menu decl	
253	<local_id_tail_menu>	=>	collect	-	[TableDecl(CONTEXT,$1)] + $3	Menu table var	
254	<local_id_tail_menu>	=>	collect	-	$1	Menu array decl	
255	<local_id_tail_menu>	=>	collect	-	[Assignment(($0(CONTEXT) if $0 else CONTEXT), $1, $2)] + $4	Menu assignment acc	
256	<local_id_tail_menu>	=>	collect	-	[Assignment(CONTEXT, $0, $1)] + $3	Menu assignment	
257	<local_id_tail_menu>	=>	collect	-	[ExpressionStatement($0)] + $2	Menu call/tail	
258	<endsb_tail_menu>	=>	collect	-	[ArrayDecl(CONTEXT,$1,$3.value,$4)] + $6	Menu array decl end	
259	<endsb_tail_menu>	=>	collect	-	[Assignment(($0(CONTEXT) if $0 else CONTEXT), $1, $2)] + $4	Menu array assign end	
260	<looping_st>	=>	propagate	-	$0	Pass loop	
261	<looping_st>	=>	propagate	-	$0	Repeat loop	
262	<looping_st>	=>	propagate	-	$0	Order loop	
263	<loop_pass>	=>	create	ForLoop	init=$2 update=$3 condition=$4 body=$6	For loop	
264	<initialization>	=>	create	Assignment	target=Identifier($0.value) operator== value=$1	Loop init	
265	<loop_init>	=>	propagate	-	$1	Has init value	
266	<loop_init>	=>	skip	-	-	No init value	
267	<update>	=>	create	Assignment	target=Identifier($0.value) accessor=$1 operator=$2 value=$3	Loop update	
268	<loop_platter>	=>	create	Platter	local_decls=$1 statements=$2	Loop body	
269	<local_decl_loop>	=>	collect	-	$1 + $2	Loop piece decl	
270	<local_decl_loop>	=>	collect	-	$1 + $2	Loop chars decl	
271	<local_decl_loop>	=>	collect	-	$1 + $2	Loop sip decl	
272	<local_decl_loop>	=>	collect	-	$1 + $2	Loop flag decl	
273	<local_decl_loop>	=>	collect	-	$1	Loop table decl	
274	<local_decl_loop>	=>	collect	-	[]	No more loop decl	
275	<local_id_tail_loop>	=>	collect	-	[TableDecl(CONTEXT,$1)] + $3	Loop table var	
276	<local_id_tail_loop>	=>	collect	-	$1	Loop array decl	
277	<local_id_tail_loop>	=>	collect	-	[Assignment(($0(CONTEXT) if $0 else CONTEXT), $1, $2)] + $4	Loop assignment acc	
278	<local_id_tail_loop>	=>	collect	-	[Assignment(CONTEXT, $0, $1)] + $3	Loop assignment	
279	<local_id_tail_loop>	=>	collect	-	[ExpressionStatement($0)] + $2	Loop call/tail	
280	<endsb_tail_loop>	=>	collect	-	[ArrayDecl(CONTEXT,$1,$3.value,$4)] + $6	Loop array decl end	
281	<endsb_tail_loop>	=>	collect	-	[Assignment(($0(CONTEXT) if $0 else CONTEXT), $1, $2)] + $4	Loop array assign end	
282	<statements_loop>	=>	collect	-	[$0] + $1	Loop stmt ID	
283	<statements_loop>	=>	collect	-	[ExpressionStatement($0)] + $2	Loop built-in	
284	<statements_loop>	=>	collect	-	[$0] + $1	Loop conditional	
285	<statements_loop>	=>	collect	-	[$0] + $1	Loop looping	
286	<statements_loop>	=>	collect	-	[$0] + $1	Loop jump	
287	<statements_loop>	=>	collect	-	[]	No more loop stmts	
288	<id_statements_loop>	=>	propagate	-	$1	Loop ID stmt ext	
289	<conditional_st_loop>	=>	propagate	-	$0	Loop cond check	
290	<conditional_st_loop>	=>	propagate	-	$0	Loop cond menu	
291	<cond_check_loop>	=>	create	IfStatement	condition=$2 then_block=$4 elif_clauses=$5 else_block=$6	Loop if stmt	
292	<alt_clause_loop>	=>	collect	-	[($2,$4)] + $5	Loop elif	
293	<alt_clause_loop>	=>	collect	-	[]	No loop elif	
294	<instead_clause_loop>	=>	propagate	-	$1	Loop else	
295	<instead_clause_loop>	=>	skip	-	-	No loop else	
296	<cond_menu_loop>	=>	create	SwitchStatement	expr=$2 cases=$4	Loop switch	
297	<menu_loop_platter>	=>	collect	-	$1 + $2	Loop menu body	
298	<choice_clause_loop>	=>	collect	-	[CaseClause($1,$3)] + $4	Loop case clause	
299	<choice_clause_loop>	=>	collect	-	[]	No more loop cases	
300	<usual_clause_loop>	=>	propagate	-	$2	Usual clause loop	
301	<usual_clause_loop>	=>	collect	-	[]	No usual loop	
302	<choice_usual_loop_st>	=>	collect	-	[$0] + $1	Loop usual stmt ID	
303	<choice_usual_loop_st>	=>	collect	-	[ExpressionStatement($0)] + $2	Loop usual built-in	
304	<choice_usual_loop_st>	=>	collect	-	[$0] + $1	Loop usual cond	
305	<choice_usual_loop_st>	=>	collect	-	[$0] + $1	Loop usual looping	
306	<choice_usual_loop_st>	=>	collect	-	[$0] + $1	Loop usual jump	
307	<choice_usual_loop_st>	=>	collect	-	[]	No more loop usual	
308	<id_statements_choice_usual_loop>	=>	propagate	-	$1	Loop usual ID ext	
309	<jump_st>	=>	propagate	-	$0	Jump next	
310	<jump_st>	=>	propagate	-	$0	Jump stop	
311	<jump_st>	=>	propagate	-	$0	Jump serve	
312	<jump_next>	=>	create	ContinueStatement	-	-	Continue
313	<jump_stop>	=>	create	BreakStatement	-	-	Break
314	<jump_serve>	=>	create	ReturnStatement	value=$1	Return	
315	<loop_repeat>	=>	create	WhileLoop	condition=$2 body=$4	While loop	
316	<loop_order>	=>	create	DoWhileLoop	body=$1 condition=$4	Do-while loop	
317	<usual_clause>	=>	propagate	-	$2	Usual clause (default)	
318	<usual_clause>	=>	collect	-	[]	No usual clause	
319	<strict_chars_expr>	=>	build_binop	-	left=$0 right=$1	Chars expression	
320	<strict_chars_factor>	=>	propagate	-	$0	Chars factor ret	
321	<strict_chars_factor>	=>	propagate	-	$0	Chars factor ID	
322	<strict_chars_factor>	=>	propagate	-	$1	Chars factor paren	
323	<strict_chars_add_tail>	=>	build_binop	-	op=+ right=$1 tail=$2	Chars add tail	
324	<strict_chars_add_tail>	=>	skip	-	-	Empty chars tail	
325	<strict_piece_expr>	=>	build_binop	-	left=$0 right=$1	Piece expression with tail	
326	<strict_piece_term>	=>	build_binop	-	left=$0 right=$1	Piece term with tail	
327	<strict_piece_factor>	=>	propagate	-	$0	Factor is ret_piece	
328	<strict_piece_factor>	=>	propagate	-	$0	Factor is identifier	
329	<strict_piece_factor>	=>	propagate	-	$1	Parenthesized expression	
330	<strict_piece_mult_tail>	=>	build_binop	-	op=* right=$1 tail=$2	Piece mult tail	
331	<strict_piece_mult_tail>	=>	build_binop	-	op=/ right=$1 tail=$2	Piece div tail	
332	<strict_piece_mult_tail>	=>	build_binop	-	op=% right=$1 tail=$2	Piece mod tail	
333	<strict_piece_mult_tail>	=>	skip	-	-	Empty mult tail	
334	<strict_piece_add_tail>	=>	build_binop	-	op=+ right=$1 tail=$2	Piece add tail	
335	<strict_piece_add_tail>	=>	build_binop	-	op=- right=$1 tail=$2	Piece sub tail	
336	<strict_piece_add_tail>	=>	skip	-	-	Empty add tail	
337	<strict_sip_expr>	=>	build_binop	-	left=$0 right=$1	Sip expression	
338	<strict_sip_term>	=>	build_binop	-	left=$0 right=$1	Sip term	
339	<strict_sip_factor>	=>	propagate	-	$0	Sip factor ID	
340	<strict_sip_factor>	=>	propagate	-	$0	Sip factor ret	
341	<strict_sip_factor>	=>	propagate	-	$1	Sip factor paren	
342	<strict_sip_mult_tail>	=>	build_binop	-	op=* right=$1 tail=$2	Sip mult tail	
343	<strict_sip_mult_tail>	=>	build_binop	-	op=/ right=$1 tail=$2	Sip div tail	
344	<strict_sip_mult_tail>	=>	skip	-	-	Empty sip mult	
345	<strict_sip_add_tail>	=>	build_binop	-	op=+ right=$1 tail=$2	Sip add tail	
346	<strict_sip_add_tail>	=>	build_binop	-	op=- right=$1 tail=$2	Sip sub tail	
347	<strict_sip_add_tail>	=>	skip	-	-	Empty sip add	
348	<ret_flag>	=>	create	FunctionCall	name=matches args=[$2,$4]	matches function	
349	<ret_flag>	=>	create	Literal	value_type=flag value=$0.value	Flag literal	
350	<ret_chars>	=>	create	FunctionCall	name=bill args=[$2]	bill function	
351	<ret_chars>	=>	create	FunctionCall	name=take args=[]	take function	
352	<ret_chars>	=>	create	FunctionCall	name=copy args=[$2,$4,$6]	copy function	
353	<ret_chars>	=>	create	FunctionCall	name=cut args=[$2,$4]	cut function	
354	<ret_chars>	=>	create	FunctionCall	name=tochars args=[$2]	tochars cast	
355	<ret_chars>	=>	create	Literal	value_type=chars value=$0.value	Chars literal	
356	<ret_piece>	=>	create	FunctionCall	name=topiece args=[$2]	topiece cast	
357	<ret_piece>	=>	create	FunctionCall	name=size args=[$2]	size() function	
358	<ret_piece>	=>	create	FunctionCall	name=search args=[$2,$4]	search() function	
359	<ret_piece>	=>	create	FunctionCall	name=fact args=[$2]	fact() function	
360	<ret_piece>	=>	create	FunctionCall	name=pow args=[$2,$4]	pow() function	
361	<ret_piece>	=>	create	Literal	value_type=piece value=$0.value	Piece literal	
362	<ret_sip>	=>	create	FunctionCall	name=sqrt args=[$2]	sqrt function	
363	<ret_sip>	=>	create	FunctionCall	name=rand args=[]	rand function	
364	<ret_sip>	=>	create	FunctionCall	name=tosip args=[$2]	tosip cast	
365	<ret_sip>	=>	create	Literal	value_type=sip value=$0.value	Sip literal	
366	<ret_array>	=>	create	FunctionCall	name=append args=[$2,$4]	append()	
367	<ret_array>	=>	create	FunctionCall	name=sort args=[$2]	sort()	
368	<ret_array>	=>	create	FunctionCall	name=reverse args=[$2]	reverse()	
369	<ret_array>	=>	create	FunctionCall	name=remove args=[$2,$4]	remove()	
370	<strict_datas_expr>	=>	create	ArrayLiteral	elements=$1	Strict datas array	
371	<strict_datas_expr>	=>	propagate	-	$0	Strict datas ID	
372	<strict_datas_expr>	=>	propagate	-	$0	Strict datas ret	
373	<strict_array_expr>	=>	create	ArrayLiteral	elements=$1	Array literal with elements	
374	<strict_array_expr>	=>	propagate	-	$0	Array ID with tail	
375	<strict_array_expr>	=>	propagate	-	$0	Result of ret_array	
376	<id>	=>	build_access	-	base=$0 tail=$1	Identifier with accessor/call	
377	<id_tail>	=>	propagate	-	$0	Call tail	
378	<id_tail>	=>	propagate	-	$0	Accessor tail	
379	<call_tailopt>	=>	build_call	-	args=$1	Function call	
380	<call_tailopt>	=>	skip	-	-	No call	
381	<chars_ops>	=>	token	-	value=+	+	
382	<sip_ops>	=>	token	-	value=+	+	
383	<sip_ops>	=>	token	-	value=-	-	
384	<sip_ops>	=>	token	-	value=*	*	
385	<sip_ops>	=>	token	-	value=/	/	
386	<all_ops>	=>	token	-	value=%	%	
387	<all_ops>	=>	propagate	-	$0	Sip ops	
388	<rel_op>	=>	token	-	value==	==	
389	<rel_op>	=>	token	-	value!=	!=	
390	<rel_op>	=>	token	-	value>=	>=	
391	<rel_op>	=>	token	-	value<=	<=	
392	<rel_op>	=>	token	-	value<	<	
393	<rel_op>	=>	token	-	value>	>	
394	<flag_eq_tail>	=>	build_binop	-	op="==" right=$1 tail=$2	Flag eq	
395	<flag_eq_tail>	=>	build_binop	-	op="!=" right=$1 tail=$2	Flag neq	
396	<flag_eq_tail>	=>	skip	-	-	Empty flag eq	
397	<flag_op_tail>	=>	manual	-	(lambda eq_tail, expr_tail: (lambda left: expr_tail(eq_tail(left))) if (eq_tail and expr_tail) else (expr_tail if expr_tail else eq_tail))($0, $1)	Flag Binop	
398	<flag_op_tail>	=>	skip	-	-	Empty flag op	
399	<cont_sip>	=>	build_binop	-	op=$0 right=$1	Sip continuation	
400	<cont_sip>	=>	skip	-	-	Empty sip cont	
401	<cont_piece>	=>	build_binop	-	op=$0 right=$1	Piece continuation	
402	<cont_piece>	=>	skip	-	-	Empty piece cont	
403	<cont_chars>	=>	build_binop	-	op=$0 right=$1	Chars continuation	
404	<cont_chars>	=>	skip	-	-	Empty chars cont	
405	<strict_flag_expr>	=>	build_binop	-	left=$0 right=$1	Flag expr	
406	<flag_expr_tail>	=>	build_binop	-	op=and right=$1	Flag expr and	
407	<flag_expr_tail>	=>	build_binop	-	op=or right=$1	Flag expr or	
408	<flag_expr_tail>	=>	skip	-	-	Empty flag expr tail	
409	<simple_flag>	=>	propagate	-	$1	Paren flag operand	
410	<simple_flag>	=>	propagate	-	$0	Flag operand	
411	<flag_operand>	=>	build_binop	-	left=$0 right=$1 tail=$2	Flag operand piece	
412	<flag_operand>	=>	build_binop	-	left=$0 right=$1 tail=$2	Flag operand sip	
413	<flag_operand>	=>	build_binop	-	left=$0 right=$1	Flag operand ret	
414	<flag_operand>	=>	build_binop	-	left=$0 right=$1 tail=$2	Flag operand chars	
415	<flag_operand>	=>	build_unary	-	operator=not operand=$1 tail=$2	Flag operand not	
416	<flag_operand>	=>	build_binop	-	left=$0 right=$1	Flag operand ID	
417	<flag_operand>	=>	build_binop	-	left=$1 right=$3	Flag operand paren	
418	<flag_cont_any>	=>	build_binop	-	op=+ right=$1	Flag cont add	
419	<flag_cont_any>	=>	build_binop	-	op=- right=$1	Flag cont sub	
420	<flag_cont_any>	=>	build_binop	-	op=* right=$1	Flag cont mult	
421	<flag_cont_any>	=>	build_binop	-	op=/ right=$1	Flag cont div	
422	<flag_cont_any>	=>	manual	-	lambda left: BinaryOp(BinaryOp(left, "%", $1), $2, $3)	Flag cont mod rel	
423	<flag_cont_any>	=>	build_binop	-	op=$0 right=$1 tail=$2	Flag cont rel	
424	<flag_cont_any>	=>	skip	-	-	Empty flag cont any	
425	<flag_cps_expr>	=>	build_binop	-	left=$0 right=$1 tail=$2	Flag cps piece	
426	<flag_cps_expr>	=>	build_binop	-	left=$0 right=$1 tail=$2	Flag cps sip	
427	<flag_cps_expr>	=>	build_binop	-	left=$0 right=$1 tail=$2	Flag cps chars	
428	<flag_cps_expr>	=>	build_binop	-	left=$0 right=$1	Flag cps ID	
429	<flag_cps_expr>	=>	build_binop	-	left=$1 right=$3	Flag cps paren	
430	<flag_cps_cont_any>	=>	build_binop	-	op=+ right=$1	Flag cps cont add	
431	<flag_cps_cont_any>	=>	build_binop	-	op=- right=$1	Flag cps cont sub	
432	<flag_cps_cont_any>	=>	build_binop	-	op=* right=$1	Flag cps cont mult	
433	<flag_cps_cont_any>	=>	build_binop	-	op=/ right=$1	Flag cps cont div	
434	<flag_cps_cont_any>	=>	build_binop	-	op=% right=$1 tail=$2	Flag cps cont mod	
435	<flag_cps_cont_any>	=>	build_binop	-	op=$0 right=$1 tail=$2	Flag cps cont rel	
436	<flag_ps_expr>	=>	build_binop	-	left=$0 right=$1 tail=$2	Flag ps piece	
437	<flag_ps_expr>	=>	build_binop	-	left=$0 right=$1 tail=$2	Flag ps sip	
438	<flag_ps_expr>	=>	build_binop	-	left=$0 right=$1	Flag ps ID	
439	<flag_ps_expr>	=>	build_binop	-	left=$1 right=$3	Flag ps paren	
440	<flag_ps_cont_any>	=>	build_binop	-	op=+ right=$1	Flag ps cont add	
441	<flag_ps_cont_any>	=>	build_binop	-	op=- right=$1	Flag ps cont sub	
442	<flag_ps_cont_any>	=>	build_binop	-	op=* right=$1	Flag ps cont mult	
443	<flag_ps_cont_any>	=>	build_binop	-	op=/ right=$1	Flag ps cont div	
444	<flag_ps_cont_any>	=>	build_binop	-	op=% right=$1 tail=$2	Flag ps cont mod	
445	<flag_ps_cont_any>	=>	build_binop	-	op=$0 right=$1 tail=$2	Flag ps cont rel	
446	<any_expr>	=>	build_binop	-	left=$0 right=$1 tail=$2	Any piece	
447	<any_expr>	=>	build_binop	-	left=$0 right=$1 tail=$2	Any sip	
448	<any_expr>	=>	build_binop	-	left=$0 right=$1	Any flag	
449	<any_expr>	=>	build_binop	-	left=$0 right=$1 tail=$2	Any chars	
450	<any_expr>	=>	build_binop	-	left=$0 right=$1	Any ID	
451	<any_expr>	=>	build_binop	-	left=$1 right=$3	Any paren	
452	<any_expr>	=>	create	UnaryOp	operator=not operand=$1	Any not	
453	<any_cont_any>	=>	build_binop	-	op=+ right=$1 tail=$2	Any cont add	
454	<any_cont_any>	=>	build_binop	-	op=- right=$1 tail=$2	Any cont sub	
455	<any_cont_any>	=>	build_binop	-	op=* right=$1 tail=$2	Any cont mult	
456	<any_cont_any>	=>	build_binop	-	op=/ right=$1 tail=$2	Any cont div	
457	<any_cont_any>	=>	build_binop	-	op=% right=$1 tail=$2	Any cont mod	
458	<any_cont_any>	=>	build_binop	-	op=$0 right=$1 tail=$2	Any cont rel	
459	<any_cont_any>	=>	propagate	-	$0	Any cont flag	
460	<any_cont_any>	=>	skip	-	-	Empty any cont	
461	<any_cont_cps_flag_tail>	=>	build_binop	-	op=$0 right=$1 tail=$2	Any cps tail	
462	<any_cont_cps_flag_tail>	=>	skip	-	-	Empty cps tail	
463	<any_cont_ps_flag_tail>	=>	build_binop	-	op=$0 right=$1 tail=$2	Any ps tail	
464	<any_cont_ps_flag_tail>	=>	skip	-	-	Empty ps tail	
465	<any_cont_p_flag_tail>	=>	build_binop	-	op=$0 right=$1 tail=$2	Any p tail	
466	<any_cont_p_flag_tail>	=>	skip	-	-	Empty p tail	
467	<any_cont_s_flag_tail>	=>	build_binop	-	op=$0 right=$1 tail=$2	Any s tail	
468	<any_cont_s_flag_tail>	=>	skip	-	-	Empty s tail	
469	<any_cont_c_flag_tail>	=>	build_binop	-	op=$0 right=$1 tail=$2	Any c tail	
470	<any_cont_c_flag_tail>	=>	skip	-	-	Empty c tail	
471	<strict_cps_expr>	=>	build_binop	-	left=$0 right=$1	Strict cps piece	
472	<strict_cps_expr>	=>	build_binop	-	left=$0 right=$1	Strict cps sip	
473	<strict_cps_expr>	=>	build_binop	-	left=$0 right=$1	Strict cps chars	
474	<strict_cps_expr>	=>	build_binop	-	left=$0 right=$1	Strict cps ID	
475	<strict_cps_expr>	=>	build_binop	-	left=$1 right=$3	Strict cps paren	
476	<cps_cont_any>	=>	build_binop	-	op=+ right=$1	Cps cont add	
477	<cps_cont_any>	=>	build_binop	-	op=- right=$1	Cps cont sub	
478	<cps_cont_any>	=>	build_binop	-	op=* right=$1	Cps cont mult	
479	<cps_cont_any>	=>	build_binop	-	op=/ right=$1	Cps cont div	
480	<cps_cont_any>	=>	build_binop	-	op=% right=$1	Cps cont mod	
481	<cps_cont_any>	=>	skip	-	-	Empty cps cont	
482	<strict_ps_expr>	=>	build_binop	-	left=$0 right=$1	Strict ps piece	
483	<strict_ps_expr>	=>	build_binop	-	left=$0 right=$1	Strict ps sip	
484	<strict_ps_expr>	=>	build_binop	-	left=$0 right=$1	Strict ps ID	
485	<strict_ps_expr>	=>	build_binop	-	left=$1 right=$3	Strict ps paren	
486	<ps_cont_any>	=>	build_binop	-	op=+ right=$1	Ps cont add	
487	<ps_cont_any>	=>	build_binop	-	op=- right=$1	Ps cont sub	
488	<ps_cont_any>	=>	build_binop	-	op=* right=$1	Ps cont mult	
489	<ps_cont_any>	=>	build_binop	-	op=/ right=$1	Ps cont div	
490	<ps_cont_any>	=>	build_binop	-	op=% right=$1	Ps cont mod	
491	<ps_cont_any>	=>	skip	-	-	Empty ps cont	
492	<strict_piece_chars_expr>	=>	build_binop	-	left=$0 right=$1	Piece/chars ID	
493	<strict_piece_chars_expr>	=>	build_binop	-	left=$0 right=$1 tail=$2	Piece/chars piece	
494	<strict_piece_chars_expr>	=>	build_binop	-	left=$0 right=$1	Piece/chars chars	
495	<strict_piece_chars_expr>	=>	build_binop	-	left=$1 right=$3	Piece/chars paren	
496	<pc_ambig_tail>	=>	build_binop	-	op=+ right=$1	PC ambig add	
497	<pc_ambig_tail>	=>	build_binop	-	op=- right=$1	PC ambig sub	
498	<pc_ambig_tail>	=>	build_binop	-	op=* right=$1	PC ambig mult	
499	<pc_ambig_tail>	=>	build_binop	-	op=/ right=$1	PC ambig div	
500	<pc_ambig_tail>	=>	build_binop	-	op=% right=$1	PC ambig mod	
501	<pc_ambig_tail>	=>	skip	-	-	Empty PC ambig	