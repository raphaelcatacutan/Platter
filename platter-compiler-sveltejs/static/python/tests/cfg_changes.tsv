<program>	=>	<global_decl>	<recipe_decl>	start	(	)	<platter>		
<global_decl>	=>	piece	<piece_decl>	<global_decl>					
<global_decl>	=>	chars	<chars_decl>	<global_decl>					
<global_decl>	=>	sip	<sip_decl>	<global_decl>					
<global_decl>	=>	flag	<flag_decl>	<global_decl>					
<global_decl>	=>	<table_prototype>	<global_decl>						
<global_decl>	=>	id	<table_decl>	<global_decl>					
<global_decl>	=>	λ							
<piece_decl>	=>	of	<piece_id>	;					
<piece_decl>	=>	<decl_type>							
<piece_id>	=>	id	<piece_ingredient_init>	<piece_id_tail>					
<piece_ingredient_init>	=>	=	<strict_piece_expr>						
<piece_ingredient_init>	=>	λ							
<strict_piece_expr>	=>	<strict_piece_term>	<strict_piece_add_tail>						
<strict_piece_term>	=>	<strict_piece_factor>	<strict_piece_mult_tail>						
<strict_piece_factor>	=>	<ret_piece>							
<strict_piece_factor>	=>	<id>							
<strict_piece_factor>	=>	(	<strict_piece_expr>	)					
<ret_piece>	=>	topiece	(	<any_expr>	)				
<ret_piece>	=>	size	(	<strict_array_expr>	)				
<ret_piece>	=>	search	(	<strict_array_expr>	,	<value>	)		
<ret_piece>	=>	fact	(	<strict_piece_expr>	)				
<ret_piece>	=>	pow	(	<strict_piece_expr>	,	<strict_piece_expr>	)		
<ret_piece>	=>	piece_lit							
<any_expr>	=>	<ret_piece>	<piece_mult_tail>	<piece_add_tail>	<piece_rel_gate>				
<any_expr>	=>	<ret_sip>	<sip_mult_tail>	<sip_add_tail>	<sip_rel_gate>				
<any_expr>	=>	<ret_chars>	<chars_add_tail>	<chars_rel_gate>					
<any_expr>	=>	<ret_flag>	<flag_logic_tail>						
<any_expr>	=>	<id>	<univ_mult_tail>	<univ_add_tail>	<univ_rel_gate>				
<any_expr>	=>	(	<paren_dispatch>						
<any_expr>	=>	not	<must_be_flag>						
<piece_mult_tail>	=>	*	<piece_factor>	<piece_mult_tail>					
<piece_mult_tail>	=>	/	<piece_factor>	<piece_mult_tail>					
<piece_mult_tail>	=>	%	<piece_factor>	<piece_mult_tail>					
<piece_mult_tail>	=>	λ							
<piece_factor>	=>	<ret_piece>							
<piece_factor>	=>	<id>							
<piece_factor>	=>	(	<piece_inner_dispatch>						
<id>	=>	id	<id_tail>						
<id_tail>	=>	<call_tailopt>							
<id_tail>	=>	<accessor_tail>							
<call_tailopt>	=>	(	<flavor>	)					
<call_tailopt>	=>	λ							
<flavor>	=>	<value>	<flavor_tail>						
<flavor>	=>	λ							
<value>	=>	<ret_piece>	<piece_mult_tail>	<piece_add_tail>	<piece_rel_gate>				
<value>	=>	<ret_sip>	<sip_mult_tail>	<sip_add_tail>	<sip_rel_gate>				
<value>	=>	<ret_chars>	<chars_add_tail>	<chars_rel_gate>					
<value>	=>	<ret_flag>	<flag_logic_tail>						
<value>	=>	(	<paren_dispatch>						
<value>	=>	not	<must_be_flag>						
<value>	=>	[	<notation_val>	]					
<value>	=>	<ret_array>							
<value>	=>	id	<id_tail>	<univ_mult_tail>	<univ_add_tail>	<univ_rel_gate>			
<piece_add_tail>	=>	+	<piece_term>	<piece_add_tail>					
<piece_add_tail>	=>	-	<piece_term>	<piece_add_tail>					
<piece_add_tail>	=>	λ							
<piece_term>	=>	<piece_factor>	<piece_mult_tail>						
<piece_rel_gate>	=>	==	<piece_expr>	<flag_logic_tail>					
<piece_rel_gate>	=>	!=	<piece_expr>	<flag_logic_tail>					
<piece_rel_gate>	=>	<=	<piece_expr>	<flag_logic_tail>					
<piece_rel_gate>	=>	>=	<piece_expr>	<flag_logic_tail>					
<piece_rel_gate>	=>	<	<piece_expr>	<flag_logic_tail>					
<piece_rel_gate>	=>	>	<piece_expr>	<flag_logic_tail>					
<piece_rel_gate>	=>	λ							
<piece_expr>	=>	<piece_term>	<piece_add_tail>						
<flag_logic_tail>	=>	and	<must_be_flag>						
<flag_logic_tail>	=>	or	<must_be_flag>						
<flag_logic_tail>	=>	==	<must_be_flag>						
<flag_logic_tail>	=>	!=	<must_be_flag>						
<flag_logic_tail>	=>	λ							
<must_be_flag>	=>	<ret_piece>	<piece_mult_tail>	<piece_add_tail>	<piece_trap_gate>				
<must_be_flag>	=>	<ret_sip>	<sip_mult_tail>	<sip_add_tail>	<sip_trap_gate>				
<must_be_flag>	=>	<ret_chars>	<chars_add_tail>	<chars_trap_gate>					
<must_be_flag>	=>	<ret_flag>	<flag_logic_tail>						
<must_be_flag>	=>	<id>	<univ_mult_tail>	<univ_add_tail>	<univ_rel_gate>				
<must_be_flag>	=>	(	<paren_dispatch>	<flag_after_paren>					
<must_be_flag>	=>	not	<must_be_flag>						
<piece_trap_gate>	=>	==	<piece_expr>	<flag_logic_tail>					
<piece_trap_gate>	=>	!=	<piece_expr>	<flag_logic_tail>					
<piece_trap_gate>	=>	<=	<piece_expr>	<flag_logic_tail>					
<piece_trap_gate>	=>	>=	<piece_expr>	<flag_logic_tail>					
<piece_trap_gate>	=>	<	<piece_expr>	<flag_logic_tail>					
<piece_trap_gate>	=>	>	<piece_expr>	<flag_logic_tail>					
<ret_sip>	=>	sqrt	(	<strict_piece_expr>	)				
<ret_sip>	=>	rand	(	)					
<ret_sip>	=>	tosip	(	<any_expr>	)				
<ret_sip>	=>	sip_lit							
<sip_mult_tail>	=>	*	<sip_factor>	<sip_mult_tail>					
<sip_mult_tail>	=>	/	<sip_factor>	<sip_mult_tail>					
<sip_mult_tail>	=>	λ							
<sip_factor>	=>	<ret_sip>							
<sip_factor>	=>	<id>							
<sip_factor>	=>	(	<sip_inner_dispatch>						
<sip_inner_dispatch>	=>	<ret_sip>	<sip_mult_tail>	<sip_add_tail>	<sip_bridge_recurse>				
<sip_inner_dispatch>	=>	<id>	<sip_mult_tail>	<sip_add_tail>	<sip_bridge_recurse>				
<sip_inner_dispatch>	=>	(	<sip_inner_dispatch>	<sip_close_recurse>					
<sip_add_tail>	=>	+	<sip_term>	<sip_add_tail>					
<sip_add_tail>	=>	-	<sip_term>	<sip_add_tail>					
<sip_add_tail>	=>	λ							
<sip_term>	=>	<sip_factor>	<sip_mult_tail>						
<sip_bridge_recurse>	=>	)							
<sip_close_recurse>	=>	)							
<sip_trap_gate>	=>	==	<sip_expr>	<flag_logic_tail>					
<sip_trap_gate>	=>	!=	<sip_expr>	<flag_logic_tail>					
<sip_trap_gate>	=>	<=	<sip_expr>	<flag_logic_tail>					
<sip_trap_gate>	=>	>=	<sip_expr>	<flag_logic_tail>					
<sip_trap_gate>	=>	<	<sip_expr>	<flag_logic_tail>					
<sip_trap_gate>	=>	>	<sip_expr>	<flag_logic_tail>					
<sip_expr>	=>	<sip_term>	<sip_add_tail>						
<ret_chars>	=>	bill	(	<strict_chars_expr>	)				
<ret_chars>	=>	take	(	)					
<ret_chars>	=>	copy	(	<strict_chars_expr>	,	<strict_piece_expr>	,	<strict_piece_expr>	)
<ret_chars>	=>	cut	(	<strict_sip_expr>	,	<strict_sip_expr>	)		
<ret_chars>	=>	tochars	(	<any_expr>	)				
<ret_chars>	=>	chars_lit							
<strict_chars_expr>	=>	<strict_chars_factor>	<strict_chars_add_tail>						
<strict_chars_factor>	=>	<ret_chars>							
<strict_chars_factor>	=>	<id>							
<strict_chars_factor>	=>	(	<strict_chars_expr>	)					
<strict_chars_add_tail>	=>	+	<strict_chars_factor>	<strict_chars_add_tail>					
<strict_chars_add_tail>	=>	λ							
<strict_sip_expr>	=>	<strict_sip_term>	<strict_sip_add_tail>						
<strict_sip_term>	=>	<strict_sip_factor>	<strict_sip_mult_tail>						
<strict_sip_factor>	=>	<ret_sip>							
<strict_sip_factor>	=>	<id>							
<strict_sip_factor>	=>	(	<strict_sip_expr>	)					
<strict_sip_mult_tail>	=>	*	<strict_sip_factor>	<strict_sip_mult_tail>					
<strict_sip_mult_tail>	=>	/	<strict_sip_factor>	<strict_sip_mult_tail>					
<strict_sip_mult_tail>	=>	λ							
<strict_sip_add_tail>	=>	+	<strict_sip_term>	<strict_sip_add_tail>					
<strict_sip_add_tail>	=>	-	<strict_sip_term>	<strict_sip_add_tail>					
<strict_sip_add_tail>	=>	λ							
<chars_add_tail>	=>	+	<chars_factor>	<chars_add_tail>					
<chars_add_tail>	=>	λ							
<chars_factor>	=>	<ret_chars>							
<chars_factor>	=>	<id>							
<chars_factor>	=>	(	<chars_inner_dispatch>						
<chars_inner_dispatch>	=>	<ret_chars>	<chars_add_tail>	<chars_bridge_recurse>					
<chars_inner_dispatch>	=>	<id>	<chars_add_tail>	<chars_bridge_recurse>					
<chars_inner_dispatch>	=>	(	<chars_inner_dispatch>	<chars_close_recurse>					
<chars_bridge_recurse>	=>	)							
<chars_close_recurse>	=>	)							
<chars_trap_gate>	=>	==	<chars_expr>	<flag_logic_tail>					
<chars_trap_gate>	=>	!=	<chars_expr>	<flag_logic_tail>					
<chars_trap_gate>	=>	<=	<chars_expr>	<flag_logic_tail>					
<chars_trap_gate>	=>	>=	<chars_expr>	<flag_logic_tail>					
<chars_trap_gate>	=>	<	<chars_expr>	<flag_logic_tail>					
<chars_trap_gate>	=>	>	<chars_expr>	<flag_logic_tail>					
<chars_expr>	=>	<chars_factor>	<chars_add_tail>						
<ret_flag>	=>	matches	(	<strict_datas_expr>	,	<strict_datas_expr>	)		
<ret_flag>	=>	toflag	(	<any_expr>	)				
<ret_flag>	=>	flag_lit							
<strict_datas_expr>	=>	[	<notation_val>	]					
<strict_datas_expr>	=>	id	<id_tail>						
<strict_datas_expr>	=>	<ret_array>							
<notation_val>	=>	<array_element>							
<notation_val>	=>	id	<array_or_table>						
<notation_val>	=>	λ							
<array_element>	=>	piece_lit	<element_value_tail>						
<array_element>	=>	sip_lit	<element_value_tail>						
<array_element>	=>	flag_lit	<element_value_tail>						
<array_element>	=>	chars_lit	<element_value_tail>						
<array_element>	=>	[	<notation_val>	]	<element_value_tail>				
<element_value_tail>	=>	,	<array_element_id>						
<element_value_tail>	=>	λ							
<array_element_id>	=>	id	<element_value_tail>						
<array_element_id>	=>	<array_element>							
<array_element_id>		λ							
<array_or_table>	=>	,	<array_element_id>						
<array_or_table>	=>	=	<value>	;	<field_assignments>				
<array_or_table>	=>	λ							
<field_assignments>	=>	id	=	<value>	;	<field_assignments>			
<field_assignments>	=>	λ							
<ret_array>	=>	append	(	<strict_array_expr>	,	<value>	)		
<ret_array>	=>	sort	(	<strict_array_expr>	)				
<ret_array>	=>	reverse	(	<strict_array_expr>	)				
<ret_array>	=>	remove	(	<strict_array_expr>	,	<strict_piece_expr>	)		
<strict_array_expr>	=>	[	<array_element_id>	]					
<strict_array_expr>	=>	id	<id_tail>						
<strict_array_expr>	=>	<ret_array>							
<array_accessor>	=>	[	<strict_piece_expr>	]	<accessor_tail>				
<accessor_tail>	=>	<array_accessor>							
<accessor_tail>	=>	<table_accessor>							
<accessor_tail>	=>	λ							
<table_accessor>	=>	:	id	<accessor_tail>					
<univ_mult_tail>	=>	*	<univ_factor>	<univ_mult_tail>					
<univ_mult_tail>	=>	/	<univ_factor>	<univ_mult_tail>					
<univ_mult_tail>	=>	%	<univ_factor>	<univ_mult_tail>					
<univ_mult_tail>	=>	λ							
<univ_factor>	=>	<id>							
<univ_factor>	=>	<ret_piece>							
<univ_factor>	=>	<ret_sip>							
<univ_factor>	=>	(	<any_expr>	)					
<univ_add_tail>	=>	+	<univ_term>	<univ_add_tail>					
<univ_add_tail>	=>	-	<univ_term>	<univ_add_tail>					
<univ_add_tail>	=>	λ							
<univ_term>	=>	<univ_factor>	<univ_mult_tail>						
<univ_rel_gate>	=>	==	<univ_expr>	<flag_logic_tail>					
<univ_rel_gate>	=>	!=	<univ_expr>	<flag_logic_tail>					
<univ_rel_gate>	=>	<=	<univ_expr>	<flag_logic_tail>					
<univ_rel_gate>	=>	>=	<univ_expr>	<flag_logic_tail>					
<univ_rel_gate>	=>	<	<univ_expr>	<flag_logic_tail>					
<univ_rel_gate>	=>	>	<univ_expr>	<flag_logic_tail>					
<univ_rel_gate>	=>	and	<must_be_flag>						
<univ_rel_gate>	=>	or	<must_be_flag>						
<univ_rel_gate>	=>	λ							
<univ_expr>	=>	<univ_term>	<univ_add_tail>						
<paren_dispatch>	=>	<ret_piece>	<piece_mult_tail>	<piece_add_tail>	<piece_bridge>				
<paren_dispatch>	=>	<ret_sip>	<sip_mult_tail>	<sip_add_tail>	<sip_bridge>				
<paren_dispatch>	=>	<ret_chars>	<chars_add_tail>	<chars_bridge>					
<paren_dispatch>	=>	<ret_flag>	<flag_logic_tail>	<flag_closure>					
<paren_dispatch>	=>	<id>	<univ_mult_tail>	<univ_add_tail>	<univ_bridge>				
<paren_dispatch>	=>	(	<paren_dispatch>	<univ_closure>					
<paren_dispatch>	=>	not	<must_be_flag>	<flag_closure>					
<piece_bridge>	=>	)	<piece_mult_tail>	<piece_add_tail>	<piece_rel_gate>				
<piece_bridge>	=>	==	<piece_expr>	<flag_logic_tail>	<flag_closure>				
<piece_bridge>	=>	!=	<piece_expr>	<flag_logic_tail>	<flag_closure>				
<piece_bridge>	=>	<=	<piece_expr>	<flag_logic_tail>	<flag_closure>				
<piece_bridge>	=>	>=	<piece_expr>	<flag_logic_tail>	<flag_closure>				
<piece_bridge>	=>	<	<piece_expr>	<flag_logic_tail>	<flag_closure>				
<piece_bridge>	=>	>	<piece_expr>	<flag_logic_tail>	<flag_closure>				
<flag_closure>	=>	)	<flag_logic_tail>						
<sip_bridge>	=>	)	<sip_mult_tail>	<sip_add_tail>	<sip_rel_gate>				
<sip_bridge>	=>	==	<sip_expr>	<flag_logic_tail>	<flag_closure>				
<sip_bridge>	=>	!=	<sip_expr>	<flag_logic_tail>	<flag_closure>				
<sip_bridge>	=>	<=	<sip_expr>	<flag_logic_tail>	<flag_closure>				
<sip_bridge>	=>	>=	<sip_expr>	<flag_logic_tail>	<flag_closure>				
<sip_bridge>	=>	<	<sip_expr>	<flag_logic_tail>	<flag_closure>				
<sip_bridge>	=>	>	<sip_expr>	<flag_logic_tail>	<flag_closure>				
<sip_rel_gate>	=>	==	<sip_expr>	<flag_logic_tail>					
<sip_rel_gate>	=>	!=	<sip_expr>	<flag_logic_tail>					
<sip_rel_gate>	=>	<=	<sip_expr>	<flag_logic_tail>					
<sip_rel_gate>	=>	>=	<sip_expr>	<flag_logic_tail>					
<sip_rel_gate>	=>	<	<sip_expr>	<flag_logic_tail>					
<sip_rel_gate>	=>	>	<sip_expr>	<flag_logic_tail>					
<sip_rel_gate>	=>	λ							
<chars_bridge>	=>	)	<chars_add_tail>	<chars_rel_gate>					
<chars_bridge>	=>	==	<chars_expr>	<flag_logic_tail>	<flag_closure>				
<chars_bridge>	=>	<=	<chars_expr>	<flag_logic_tail>	<flag_closure>				
<chars_bridge>	=>	>=	<chars_expr>	<flag_logic_tail>	<flag_closure>				
<chars_bridge>	=>	<	<chars_expr>	<flag_logic_tail>	<flag_closure>				
<chars_bridge>	=>	>	<chars_expr>	<flag_logic_tail>	<flag_closure>				
<chars_bridge>	=>	!=	<chars_expr>	<flag_logic_tail>	<flag_closure>				
<chars_rel_gate>	=>	<=	<chars_expr>	<flag_logic_tail>					
<chars_rel_gate>	=>	>=	<chars_expr>	<flag_logic_tail>					
<chars_rel_gate>	=>	<	<chars_expr>	<flag_logic_tail>					
<chars_rel_gate>	=>	>	<chars_expr>	<flag_logic_tail>					
<chars_rel_gate>	=>	==	<chars_expr>	<flag_logic_tail>					
<chars_rel_gate>	=>	!=	<chars_expr>	<flag_logic_tail>					
<chars_rel_gate>	=>	λ							
<univ_bridge>	=>	)	<univ_mult_tail>	<univ_add_tail>	<univ_rel_gate>				
<univ_bridge>	=>	==	<univ_expr>	<flag_logic_tail>	<flag_closure>				
<univ_bridge>	=>	!=	<univ_expr>	<flag_logic_tail>	<flag_closure>				
<univ_bridge>	=>	<=	<univ_expr>	<flag_logic_tail>	<flag_closure>				
<univ_bridge>	=>	>=	<univ_expr>	<flag_logic_tail>	<flag_closure>				
<univ_bridge>	=>	<	<univ_expr>	<flag_logic_tail>	<flag_closure>				
<univ_bridge>	=>	>	<univ_expr>	<flag_logic_tail>	<flag_closure>				
<univ_closure>	=>	)	<univ_mult_tail>	<univ_add_tail>	<univ_rel_gate>				
<flag_after_paren>	=>	λ							
<flavor_tail>	=>	,	<value>	<flavor_tail>					
<flavor_tail>	=>	λ							
<piece_inner_dispatch>	=>	<ret_piece>	<piece_mult_tail>	<piece_add_tail>	<piece_bridge_recurse>				
<piece_inner_dispatch>	=>	<id>	<piece_mult_tail>	<piece_add_tail>	<piece_bridge_recurse>				
<piece_inner_dispatch>	=>	(	<piece_inner_dispatch>	<piece_close_recurse>					
<piece_bridge_recurse>	=>	)							
<piece_close_recurse>	=>	)							
<strict_piece_mult_tail>	=>	*	<strict_piece_factor>	<strict_piece_mult_tail>					
<strict_piece_mult_tail>	=>	/	<strict_piece_factor>	<strict_piece_mult_tail>					
<strict_piece_mult_tail>	=>	%	<strict_piece_factor>	<strict_piece_mult_tail>					
<strict_piece_mult_tail>	=>	λ							
<strict_piece_add_tail>	=>	+	<strict_piece_term>	<strict_piece_add_tail>					
<strict_piece_add_tail>	=>	-	<strict_piece_term>	<strict_piece_add_tail>					
<strict_piece_add_tail>	=>	λ							
<piece_id_tail>	=>	,	id	<piece_ingredient_init>	<piece_id_tail>				
<piece_id_tail>	=>	λ							
<decl_type>	=>	<dimensions>	of	<array_declare>	;				
<dimensions>	=>	[	]	<dimensions_tail>					
<dimensions_tail>	=>	<dimensions>							
<dimensions_tail>	=>	λ							
<array_declare>	=>	id	<array_init>	<array_declare_tail>					
<array_init>	=>	=	<strict_array_expr>						
<array_init>	=>	λ							
<array_declare_tail>	=>	,	<array_declare>						
<array_declare_tail>	=>	λ							
<chars_decl>	=>	of	<chars_id>	;					
<chars_decl>	=>	<decl_type>							
<chars_id>	=>	id	<chars_ingredient_init>	<chars_id_tail>					
<chars_ingredient_init>	=>	=	<strict_chars_expr>						
<chars_ingredient_init>	=>	λ							
<chars_id_tail>	=>	,	id	<chars_ingredient_init>	<chars_id_tail>				
<chars_id_tail>	=>	λ							
<sip_decl>	=>	of	<sip_id>	;					
<sip_decl>	=>	<decl_type>							
<sip_id>	=>	id	<sip_ingredient_init>	<sip_id_tail>					
<sip_ingredient_init>	=>	=	<strict_sip_expr>						
<sip_ingredient_init>	=>	λ							
<sip_id_tail>	=>	,	id	<sip_ingredient_init>	<sip_id_tail>				
<sip_id_tail>	=>	λ							
<flag_decl>	=>	of	<flag_id>	;					
<flag_decl>	=>	<decl_type>							
<flag_id>	=>	id	<flag_ingredient_init>	<flag_id_tail>					
<flag_ingredient_init>	=>	=	<strict_flag_expr>						
<flag_ingredient_init>	=>	λ							
<strict_flag_expr>	=>	<strict_flag_term>	<strict_flag_or_tail>						
<strict_flag_term>	=>	<strict_flag_equality>	<strict_flag_and_tail>						
<strict_flag_equality>	=>	<strict_flag_factor>	<strict_flag_eq_tail>						
<strict_flag_factor>	=>	<ret_flag>							
<strict_flag_factor>	=>	not	<strict_flag_factor>						
<strict_flag_factor>	=>	<id>	<strict_id_master_tail>						
<strict_flag_factor>	=>	(	<strict_flag_paren_entry>						
<strict_flag_factor>	=>	<ret_piece>	<piece_mult_tail>	<piece_add_tail>	<strict_piece_gate>				
<strict_flag_factor>	=>	<ret_sip>	<sip_mult_tail>	<sip_add_tail>	<strict_sip_gate>				
<strict_flag_factor>	=>	<ret_chars>	<chars_add_tail>	<strict_chars_gate>					
<strict_id_master_tail>	=>	*	<univ_factor>	<univ_mult_tail>	<univ_add_tail>	<strict_forced_gate>			
<strict_id_master_tail>	=>	/	<univ_factor>	<univ_mult_tail>	<univ_add_tail>	<strict_forced_gate>			
<strict_id_master_tail>	=>	%	<univ_factor>	<univ_mult_tail>	<univ_add_tail>	<strict_forced_gate>			
<strict_id_master_tail>	=>	+	<univ_term>	<univ_add_tail>	<strict_forced_gate>				
<strict_id_master_tail>	=>	-	<univ_term>	<univ_add_tail>	<strict_forced_gate>				
<strict_id_master_tail>	=>	==	<univ_expr>						
<strict_id_master_tail>	=>	!=	<univ_expr>						
<strict_id_master_tail>	=>	<=	<comparable_expr>						
<strict_id_master_tail>	=>	>=	<comparable_expr>						
<strict_id_master_tail>	=>	<	<comparable_expr>						
<strict_id_master_tail>	=>	>	<comparable_expr>						
<strict_id_master_tail>	=>	λ							
<strict_forced_gate>	=>	==	<univ_expr>						
<strict_forced_gate>	=>	!=	<univ_expr>						
<strict_forced_gate>	=>	<=	<univ_expr>						
<strict_forced_gate>	=>	>=	<univ_expr>						
<strict_forced_gate>	=>	<	<univ_expr>						
<strict_forced_gate>	=>	>	<univ_expr>						
<comparable_expr>	=>	<comparable_term>	<comparable_add_tail>						
<comparable_term>	=>	<comparable_factor>	<comparable_mult_tail>						
<comparable_factor>	=>	<id>							
<comparable_factor>	=>	<ret_piece>							
<comparable_factor>	=>	<ret_sip>							
<comparable_factor>	=>	<ret_chars>							
<comparable_factor>	=>	(	<any_expr>	)					
<comparable_mult_tail>	=>	*	<comparable_factor>	<comparable_mult_tail>					
<comparable_mult_tail>	=>	/	<comparable_factor>	<comparable_mult_tail>					
<comparable_mult_tail>	=>	%	<comparable_factor>	<comparable_mult_tail>					
<comparable_mult_tail>	=>	λ							
<comparable_add_tail>	=>	+	<comparable_term>	<comparable_add_tail>					
<comparable_add_tail>	=>	-	<comparable_term>	<comparable_add_tail>					
<comparable_add_tail>	=>	λ							
<strict_flag_paren_entry>	=>	<ret_piece>	<piece_mult_tail>	<piece_add_tail>	<strict_paren_piece_bridge>				
<strict_flag_paren_entry>	=>	<ret_sip>	<sip_mult_tail>	<sip_add_tail>	<strict_paren_sip_bridge>				
<strict_flag_paren_entry>	=>	<ret_chars>	<chars_add_tail>	<strict_paren_chars_bridge>					
<strict_flag_paren_entry>	=>	<ret_flag>	<flag_logic_tail>	<strict_paren_flag_bridge>					
<strict_flag_paren_entry>	=>	not	<must_be_flag>	<strict_paren_flag_bridge>					
<strict_flag_paren_entry>	=>	<id>	<univ_mult_tail>	<univ_add_tail>	<strict_paren_univ_bridge>				
<strict_flag_paren_entry>	=>	(	<strict_flag_paren_entry>	<strict_paren_univ_bridge>					
<strict_paren_piece_bridge>	=>	)	<piece_mult_tail>	<piece_add_tail>	<strict_piece_gate>				
<strict_paren_piece_bridge>	=>	<strict_piece_gate>	<flag_logic_tail>	<strict_paren_flag_bridge>					
<strict_piece_gate>	=>	==	<piece_expr>						
<strict_piece_gate>	=>	!=	<piece_expr>						
<strict_piece_gate>	=>	<=	<piece_expr>						
<strict_piece_gate>	=>	>=	<piece_expr>						
<strict_piece_gate>	=>	<	<piece_expr>						
<strict_piece_gate>	=>	>	<piece_expr>						
<strict_paren_flag_bridge>	=>	)							
<strict_paren_sip_bridge>	=>	)	<sip_mult_tail>	<sip_add_tail>	<strict_sip_gate>				
<strict_paren_sip_bridge>	=>	<strict_sip_gate>	<flag_logic_tail>	<strict_paren_flag_bridge>					
<strict_sip_gate>	=>	==	<sip_expr>						
<strict_sip_gate>	=>	!=	<sip_expr>						
<strict_sip_gate>	=>	<=	<sip_expr>						
<strict_sip_gate>	=>	>=	<sip_expr>						
<strict_sip_gate>	=>	<	<sip_expr>						
<strict_sip_gate>	=>	>	<sip_expr>						
<strict_paren_chars_bridge>	=>	)	<chars_add_tail>	<strict_chars_gate>					
<strict_paren_chars_bridge>	=>	<strict_chars_gate>	<flag_logic_tail>	<strict_paren_flag_bridge>					
<strict_chars_gate>	=>	<=	<chars_expr>						
<strict_chars_gate>	=>	>=	<chars_expr>						
<strict_chars_gate>	=>	<	<chars_expr>						
<strict_chars_gate>	=>	>	<chars_expr>						
<strict_chars_gate>	=>	==	<chars_expr>						
<strict_chars_gate>	=>	!=	<chars_expr>						
<strict_paren_univ_bridge>	=>	)	<univ_mult_tail>	<univ_add_tail>	<strict_forced_gate>				
<strict_paren_univ_bridge>	=>	<strict_forced_gate>	<flag_logic_tail>	<strict_paren_flag_bridge>					
<strict_flag_eq_tail>	=>	==	<strict_flag_equality>						
<strict_flag_eq_tail>	=>	!=	<strict_flag_equality>						
<strict_flag_eq_tail>	=>	λ							
<strict_flag_and_tail>	=>	and	<strict_flag_equality>	<strict_flag_and_tail>					
<strict_flag_and_tail>	=>	λ							
<strict_flag_or_tail>	=>	or	<strict_flag_term>	<strict_flag_or_tail>					
<strict_flag_or_tail>	=>	λ							
<flag_id_tail>	=>	,	id	<flag_ingredient_init>	<flag_id_tail>				
<flag_id_tail>	=>	λ							
<table_prototype>	=>	table	of	id	=	[	<required_decl>	]	;
<required_decl>	=>	<decl_head>	;	<required_decl_tail>					
<decl_head>	=>	<primitive_types_dims>	of	id					
<primitive_types_dims>	=>	piece	<dimensions_tail>						
<primitive_types_dims>	=>	sip	<dimensions_tail>						
<primitive_types_dims>	=>	flag	<dimensions_tail>						
<primitive_types_dims>	=>	chars	<dimensions_tail>						
<primitive_types_dims>	=>	id	<dimensions_tail>						
<required_decl_tail>	=>	<required_decl>							
<required_decl_tail>	=>	λ							
<table_decl>	=>	of	<table_declare>	;					
<table_decl>	=>	<decl_type>							
<table_declare>	=>	id	<table_init>	<table_declare_tail>					
<table_init>	=>	=	<strict_table_expr>						
<table_init>	=>	λ							
<strict_table_expr>	=>	[	<field_assignments>	]					
<strict_table_expr>	=>	<id>							
<table_declare_tail>	=>	,	<table_declare>						
<table_declare_tail>	=>	λ							
<recipe_decl>	=>	prepare	<serve_type>	(	<spice>	)	<platter>	<recipe_decl>	
<recipe_decl>	=>	λ							
<serve_type>	=>	<decl_head>							
<spice>	=>	<decl_head>	<spice_tail>						
<spice>	=>	λ							
<spice_tail>	=>	,	<decl_head>	<spice_tail>					
<spice_tail>	=>	λ							
<platter>	=>	{	<local_decl>	<statements>	}				
<local_decl>	=>	piece	<piece_decl>	<local_decl>					
<local_decl>	=>	chars	<chars_decl>	<local_decl>					
<local_decl>	=>	sip	<sip_decl>	<local_decl>					
<local_decl>	=>	flag	<flag_decl>	<local_decl>					
<local_decl>	=>	id	<local_id_tail>						
<local_decl>	=>	λ							
<local_id_tail>	=>	of	<table_declare>	;	<local_decl>				
<local_id_tail>	=>	[	<]_tail>						
<local_id_tail>	=>	<table_accessor>	<assignment_op>	<value>	;	<statements>			
<local_id_tail>	=>	<assignment_op>	<value>	;	<statements>				
<local_id_tail>	=>	<tail1>	;	<statements>					
<]_tail>	=>	]	<dimensions_tail>	of	<array_declare>	;	<local_decl>		
<]_tail>	=>	<strict_piece_expr>	]	<accessor_tail>	<assignment_op>	<value>	;	<statements>	
<assignment_op>	=>	=							
<assignment_op>	=>	+=							
<assignment_op>	=>	-=							
<assignment_op>	=>	*=							
<assignment_op>	=>	/=							
<assignment_op>	=>	%=							
<statements>	=>	<id_statements>	<statements>						
<statements>	=>	<built-in_rec_call>	;	<statements>					
<statements>	=>	<conditional_st>	<statements>						
<statements>	=>	<looping_st>	<statements>						
<statements>	=>	<jump_serve>	<statements>						
<statements>	=>	λ							
<id_statements>	=>	id	<id_statements_ext>	<statements>					
<id_statements_ext>	=>	<tail1>	;						
<id_statements_ext>	=>	<assignment_st>							
<tail1>	=>	<call_tail>							
<call_tail>	=>	(	<flavor>	)					
<assignment_st>	=>	<accessor_tail>	<assignment_op>	<value>	;				
<built-in_rec_call>	=>	<built-in_rec>							
<built-in_rec>	=>	append	(	<strict_array_expr>	,	<value>	)		
<built-in_rec>	=>	bill	(	<strict_chars_expr>	)				
<built-in_rec>	=>	copy	(	<strict_chars_expr>	,	<strict_piece_expr>	,	<strict_piece_expr>	)
<built-in_rec>	=>	cut	(	<strict_sip_expr>	,	<strict_sip_expr>	)		
<built-in_rec>	=>	fact	(	<strict_piece_expr>	)				
<built-in_rec>	=>	matches	(	<strict_datas_expr>	,	<strict_datas_expr>	)		
<built-in_rec>	=>	pow	(	<strict_piece_expr>	,	<strict_piece_expr>	)		
<built-in_rec>	=>	rand	(	)					
<built-in_rec>	=>	remove	(	<strict_array_expr>	,	<strict_piece_expr>	)		
<built-in_rec>	=>	reverse	(	<strict_array_expr>	)				
<built-in_rec>	=>	search	(	<strict_array_expr>	,	<value>	)		
<built-in_rec>	=>	size	(	<strict_array_expr>	)				
<built-in_rec>	=>	sort	(	<strict_array_expr>	)				
<built-in_rec>	=>	sqrt	(	<strict_piece_expr>	)				
<built-in_rec>	=>	take	(	)					
<built-in_rec>	=>	tochars	(	<any_expr>	)				
<built-in_rec>	=>	topiece	(	<any_expr>	)				
<built-in_rec>	=>	tosip	(	<any_expr>	)				
<conditional_st>	=>	<cond_check>							
<conditional_st>	=>	<cond_menu>							
<cond_check>	=>	check	(	<strict_flag_expr>	)	<platter>	<alt_clause>	<instead_clause>	
<alt_clause>	=>	alt	(	<strict_flag_expr>	)	<platter>	<alt_clause>		
<alt_clause>	=>	λ							
<instead_clause>	=>	instead	<platter>						
<instead_clause>	=>	λ							
<cond_menu>	=>	menu	(	<any_expr>	)	<menu_platter>			
<menu_platter>	=>	{	<choice_clause>	<usual_clause>	}				
<choice_clause>	=>	choice	<choice_val>	:	<statements_menu>	<choice_clause>			
<choice_clause>	=>	λ							
<choice_val>	=>	piece_lit							
<choice_val>	=>	chars_lit							
<statements_menu>	=>	<id_statements_menu>	<statements_menu>						
<statements_menu>	=>	<built-in_rec_call>	;	<statements_menu>					
<statements_menu>	=>	<conditional_st_menu>	<statements_menu>						
<statements_menu>	=>	<looping_st>	<statements_menu>						
<statements_menu>	=>	<jump_stop>	<statements_menu>						
<statements_menu>	=>	<jump_serve>	<statements_menu>						
<statements_menu>	=>	λ							
<id_statements_menu>	=>	id	<id_statements_ext>	<statements_menu>					
<conditional_st_menu>	=>	<cond_check_menu>							
<conditional_st_menu>	=>	<cond_menu>							
<cond_check_menu>	=>	check	(	<strict_flag_expr>	)	<menu_check_platter>	<alt_clause>	<instead_clause>	
<menu_check_platter>	=>	{	<local_decl_menu>	<statements_menu>	}				
<local_decl_menu>	=>	piece	<piece_decl>	<local_decl_menu>					
<local_decl_menu>	=>	chars	<chars_decl>	<local_decl_menu>					
<local_decl_menu>	=>	sip	<sip_decl>	<local_decl_menu>					
<local_decl_menu>	=>	flag	<flag_decl>	<local_decl_menu>					
<local_decl_menu>	=>	id	<local_id_tail_menu>						
<local_decl_menu>	=>	λ							
<local_id_tail_menu>	=>	of	<table_declare>	;	<local_decl_menu>				
<local_id_tail_menu>	=>	[	<]_tail_menu>						
<local_id_tail_menu>	=>	<table_accessor>	<assignment_op>	<value>	;	<statements_menu>			
<local_id_tail_menu>	=>	<assignment_op>	<value>	;	<statements_menu>				
<local_id_tail_menu>	=>	<tail1>	;	<statements_menu>					
<]_tail_menu>	=>	]	<dimensions_tail>	of	<table_declare>	;	<local_decl_menu>		
<]_tail_menu>	=>	<strict_piece_expr>	]	<accessor_tail>	<assignment_op>	<value>	;	<statements_menu>	
<looping_st>	=>	<loop_pass>							
<looping_st>	=>	<loop_repeat>							
<looping_st>	=>	<loop_order>							
<loop_pass>	=>	pass	(	<initialization>	<update>	<strict_flag_expr>	)	<loop_platter>	
<initialization>	=>	id	<loop_init>	;					
<loop_init>	=>	=	<strict_piece_expr>						
<loop_init>	=>	λ							
<update>	=>	id	<assignment_st>						
<loop_platter>	=>	{	<local_decl_loop>	<statements_loop>	}				
<local_decl_loop>	=>	piece	<piece_decl>	<local_decl_loop>					
<local_decl_loop>	=>	chars	<chars_decl>	<local_decl_loop>					
<local_decl_loop>	=>	sip	<sip_decl>	<local_decl_loop>					
<local_decl_loop>	=>	flag	<flag_decl>	<local_decl_loop>					
<local_decl_loop>	=>	id	<local_id_tail_loop>						
<local_decl_loop>	=>	λ							
<local_id_tail_loop>	=>	of	<table_declare>	;	<local_decl_loop>				
<local_id_tail_loop>	=>	[	<]_tail_loop>						
<local_id_tail_loop>	=>	<table_accessor>	<assignment_op>	<value>	;	<statements_loop>			
<local_id_tail_loop>	=>	<assignment_op>	<value>	;	<statements_loop>				
<local_id_tail_loop>	=>	<tail1>	;	<statements_loop>					
<]_tail_loop>	=>	]	<dimensions_tail>	of	<table_declare>	;	<local_decl_loop>		
<]_tail_loop>	=>	<strict_piece_expr>	]	<accessor_tail>	<assignment_op>	<value>	;	<statements_loop>	
<statements_loop>	=>	<id_statements_loop>	<statements_loop>						
<statements_loop>	=>	<built-in_rec_call>	;	<statements_loop>					
<statements_loop>	=>	<conditional_st_loop>	<statements_loop>						
<statements_loop>	=>	<looping_st>	<statements_loop>						
<statements_loop>	=>	<jump_st>	<statements_loop>						
<statements_loop>	=>	λ							
<id_statements_loop>	=>	id	<id_statements_ext>	<statements_loop>					
<conditional_st_loop>	=>	<cond_check_loop>							
<conditional_st_loop>	=>	<cond_menu_loop>							
<cond_check_loop>	=>	check	(	<strict_flag_expr>	)	<loop_platter>	<alt_clause_loop>	<instead_clause_loop>	
<alt_clause_loop>	=>	alt	(	<strict_flag_expr>	)	<loop_platter>	<alt_clause_loop>		
<alt_clause_loop>	=>	λ							
<instead_clause_loop>	=>	instead	<loop_platter>						
<instead_clause_loop>	=>	λ							
<cond_menu_loop>	=>	menu	(	<any_expr>	)	<menu_loop_platter>			
<menu_loop_platter>	=>	{	<choice_clause_loop>	<usual_clause_loop>	}				
<choice_clause_loop>	=>	choice	<choice_val>	:	<statements_loop>	<choice_clause_loop>			
<choice_clause_loop>	=>	λ							
<usual_clause_loop>	=>	usual	:	<statements_loop>					
<usual_clause_loop>	=>	λ							
<jump_st>	=>	<jump_next>							
<jump_st>	=>	<jump_stop>							
<jump_st>	=>	<jump_serve>							
<jump_next>	=>	next	;						
<jump_stop>	=>	stop	;						
<jump_serve>	=>	serve	<value>	;					
<loop_repeat>	=>	repeat	(	<strict_flag_expr>	)	<loop_platter>			
<loop_order>	=>	order	<loop_platter>	repeat	(	<strict_flag_expr>	)	;	
<usual_clause>	=>	usual	:	<statements_menu>					
<usual_clause>	=>	λ							