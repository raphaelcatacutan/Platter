<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>CFG Visualizer & Parser (Fixed)</title>
<style>
    :root {
        --bg: #1e1e1e;
        --panel: #252526;
        --border: #333;
        --accent: #007acc;
        --text: #cccccc;
        --green: #4ec9b0;
        --red: #f48771;
        --yellow: #dcdcaa;
    }

    body {
        margin: 0;
        font-family: 'Consolas', 'Segoe UI', monospace;
        background-color: var(--bg);
        color: var(--text);
        display: flex;
        height: 100vh;
        overflow: hidden;
    }

    /* --- SIDEBAR --- */
    .sidebar {
        width: 400px;
        min-width: 300px;
        max-width: 800px;
        background-color: var(--panel);
        border-right: 1px solid var(--border);
        display: flex;
        flex-direction: column;
        padding: 10px;
        gap: 10px;
        z-index: 10;
        box-shadow: 2px 0 10px rgba(0,0,0,0.3);
        position: relative;
    }
    
    .resize-handle {
        position: absolute;
        right: 0;
        top: 0;
        bottom: 0;
        width: 5px;
        cursor: ew-resize;
        background: transparent;
        z-index: 20;
    }
    .resize-handle:hover {
        background: var(--accent);
    }

    h3 { margin: 5px 0; font-size: 0.85rem; text-transform: uppercase; color: #888; }

    textarea, input {
        background-color: #1e1e1e;
        color: #9cdcfe;
        border: 1px solid var(--border);
        padding: 8px;
        font-family: inherit;
        font-size: 12px;
        width: 100%;
        box-sizing: border-box;
    }
    textarea { height: 120px; resize: vertical; white-space: pre; }
    
    .controls { display: flex; gap: 5px; }
    
    button {
        flex: 1;
        background-color: var(--accent);
        color: white;
        border: none;
        padding: 8px;
        cursor: pointer;
        font-weight: bold;
        border-radius: 2px;
    }
    button:hover { filter: brightness(1.1); }
    button.secondary { background-color: #444; }

    /* --- LOG OUTPUT --- */
    #logPanel {
        flex: 1;
        background: #111;
        border: 1px solid var(--border);
        overflow-y: auto;
        padding: 5px;
        font-size: 11px;
    }
    .log-row { display: flex; border-bottom: 1px solid #222; padding: 2px 0; }
    .log-stack { flex: 1; color: var(--accent); overflow: hidden; white-space: nowrap; text-overflow: ellipsis; font-family: monospace; }
    .log-inp { flex: 1; color: var(--yellow); text-align: right; padding-right: 10px; overflow: hidden; white-space: nowrap; font-family: monospace; }
    .log-act { flex: 1.5; color: var(--text); font-family: monospace; }
    .log-header { display: flex; padding: 5px; background: #2a2a2a; font-weight: bold; border-bottom: 2px solid var(--accent); position: sticky; top: 0; z-index: 5; }
    .log-header-col { flex: 1; }
    .log-header .log-act { flex: 1.5; }
    .err { color: var(--red); background: rgba(255,0,0,0.1); padding: 5px; margin-bottom: 2px; border-left: 3px solid var(--red); }
    .success { color: var(--green); font-weight: bold; padding: 5px; text-align: center; background: rgba(0,255,0,0.05); }
    .log-info { color: #888; font-size: 10px; padding: 3px 5px; background: #1a1a1a; border-left: 2px solid #555; margin: 2px 0; }

    /* --- VISUALIZER --- */
    .viewport {
        flex: 1;
        position: relative;
        background: radial-gradient(#333 1px, transparent 1px);
        background-size: 20px 20px;
        overflow: hidden;
        cursor: grab;
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
    }
    .viewport:active { cursor: grabbing; }

    .stage {
        position: absolute;
        top: 20px; left: 50%;
        transform-origin: top center;
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
    }

    /* CSS Tree */
    .tree ul { padding-top: 20px; position: relative; display: flex; justify-content: center; }
    .tree li { float: left; text-align: center; list-style-type: none; position: relative; padding: 20px 5px 0 5px; }
    .tree li::before, .tree li::after { content: ''; position: absolute; top: 0; right: 50%; border-top: 1px solid #555; width: 50%; height: 20px; }
    .tree li::after { right: auto; left: 50%; border-left: 1px solid #555; }
    .tree li:only-child::after, .tree li:only-child::before { display: none; }
    .tree li:only-child { padding-top: 0; }
    .tree li:first-child::before, .tree li:last-child::after { border: 0 none; }
    .tree li:last-child::before { border-right: 1px solid #555; border-radius: 0 5px 0 0; }
    .tree li:first-child::after { border-radius: 5px 0 0 0; }
    .tree ul ul::before { content: ''; position: absolute; top: 0; left: 50%; border-left: 1px solid #555; width: 0; height: 20px; }

    .node {
        display: inline-block;
        padding: 4px 8px;
        border-radius: 3px;
        font-size: 12px;
        font-weight: bold;
        border: 1px solid #444;
        position: relative;
        z-index: 2;
        background: #2d2d2d;
    }
    .nt { background: var(--accent); color: white; cursor: pointer; }
    .t { background: #252526; color: #ce9178; }
    .opt { background: #333; border-style: dashed; color: #888; }
    
    .collapsed::after {
        content: '+'; position: absolute; bottom: -8px; left: 50%; transform: translateX(-50%);
        background: #000; color: #fff; width: 12px; height: 12px; line-height: 10px;
        border-radius: 50%; font-size: 9px;
    }
    
    /* Table Modal */
    #tableModal {
        display: none; position: fixed; top: 20px; left: 420px; right: 20px; bottom: 20px;
        background: #1e1e1e; border: 1px solid #555; z-index: 100;
        flex-direction: column; box-shadow: 0 0 20px rgba(0,0,0,0.5);
    }
    .modal-header { background: #252526; padding: 10px; display: flex; justify-content: space-between; border-bottom: 1px solid #333; }
    .modal-content { flex: 1; overflow: auto; padding: 10px; }
    table { width: 100%; border-collapse: collapse; font-size: 12px; }
    th, td { border: 1px solid #444; padding: 8px; text-align: left; }
    th { background: #333; position: sticky; top: 0; z-index: 10; }
    td.conflict { background: rgba(255, 0, 0, 0.2); }
    .match-highlight { background: rgba(76, 201, 176, 0.3); font-weight: bold; color: #4ec9b0; }
</style>
</head>
<body>

	<div class="sidebar" id="sidebar">
		<div class="resize-handle" id="resizeHandle"></div>
		<div>
			<h3>CFG Rules (TSV)</h3>
			<textarea id="cfgInput"></textarea>				
		</div>

    <div>
        <h3>Input String</h3>
        <input type="text" id="testInput" value="piece ( ) start ( )" placeholder="e.g. piece ( )">
    </div>

    <div class="controls">
        <button onclick="runParser()">Parse & Visualize</button>
        <button class="secondary" onclick="toggleTable()">Show Table</button>
    </div>
    
    <div class="controls">
        <button class="secondary" onclick="visualizeParseTree()">Visualize Parse Tree</button>
    </div>

    <div id="logPanel">Ready.</div>
</div>

<div class="viewport" id="viewport">
    <div class="stage" id="stage">
        <div class="tree" id="treeRoot"></div>
    </div>
</div>

<div id="tableModal">
    <div class="modal-header">
        <span>LL(1) Parsing Table</span>
        <button onclick="toggleTable()" style="width: auto; padding: 2px 10px;">Close</button>
    </div>
    <div class="modal-content" id="tableContent"></div>
</div>

<script>
    // --- PARSER STATE ---
    let grammar = {};
    let terminals = new Set();
    let nonTerminals = new Set();
    let startSymbol = null;
    let parseTable = {};
    let firstSets = {}, followSets = {};
    let parseTree = null;

    function runParser() {
        const log = document.getElementById('logPanel');
        log.innerHTML = '';
        
        // Save to localStorage
        localStorage.setItem('cfg_input', document.getElementById('cfgInput').value);
        localStorage.setItem('test_input', document.getElementById('testInput').value);
        
        try {
            parseGrammar();
            buildLL1Table();
            
            // Render Visual Tree
            renderTree(startSymbol);
            
            // Run Trace
            const inputStr = document.getElementById('testInput').value;
            runTrace(inputStr);

        } catch (e) {
            log.innerHTML += `<div class="err">${e.message}</div>`;
            console.error(e);
        }
    }

    // --- 1. GRAMMAR PARSING ---
    function parseGrammar() {
        const text = document.getElementById('cfgInput').value;
        grammar = {};
        terminals = new Set();
        nonTerminals = new Set();
        startSymbol = null;

        text.split('\n').forEach(line => {
            if (!line.trim()) return;
            const parts = line.split('\t').map(s => s.trim());
            if (parts.length < 3) return;

            const lhs = parts[1];
            if (!lhs.startsWith('<')) return;

            if (!startSymbol) startSymbol = lhs;
            nonTerminals.add(lhs);

            const rhs = parts.slice(3).filter(t => t !== '');
            if (!grammar[lhs]) grammar[lhs] = [];
            grammar[lhs].push(rhs);

            rhs.forEach(t => {
                if (!t.startsWith('<') && t !== 'λ') terminals.add(t);
            });
        });

        // Implicitly convert undefined NTs to Terminals to prevent crash
        // (This helps if user forgets to define a rule)
        let changed = true;
        while(changed) {
            changed = false;
            Object.values(grammar).flat().forEach(rhs => {
                rhs.forEach(token => {
                    if (token.startsWith('<') && !nonTerminals.has(token)) {
                        // console.warn(`Treating undefined ${token} as terminal`);
                        terminals.add(token);
                    }
                });
            });
        }
    }

    // --- 2. TABLE CONSTRUCTION (THE FIX) ---
    function buildLL1Table() {
        firstSets = {}; followSets = {}; parseTable = {};
        
        nonTerminals.forEach(nt => {
            firstSets[nt] = new Set();
            followSets[nt] = new Set();
            parseTable[nt] = {};
        });
        followSets[startSymbol].add('$');

        // Calc FIRST
        let changed = true;
        while(changed) {
            changed = false;
            nonTerminals.forEach(lhs => {
                grammar[lhs].forEach(rhs => {
                    const trailer = getFirstSeq(rhs);
                    trailer.forEach(t => {
                        if (!firstSets[lhs].has(t)) {
                            firstSets[lhs].add(t);
                            changed = true;
                        }
                    });
                });
            });
        }

        // Calc FOLLOW
        changed = true;
        while(changed) {
            changed = false;
            nonTerminals.forEach(lhs => {
                grammar[lhs].forEach(rhs => {
                    let trailer = new Set(followSets[lhs]);
                    for (let i = rhs.length - 1; i >= 0; i--) {
                        const B = rhs[i];
                        if (nonTerminals.has(B)) {
                            trailer.forEach(t => {
                                if(!followSets[B].has(t)) {
                                    followSets[B].add(t);
                                    changed = true;
                                }
                            });
                            const firstB = firstSets[B];
                            if(firstB.has('λ')) {
                                firstB.forEach(x => { if(x!=='λ') trailer.add(x); });
                            } else {
                                trailer = new Set(firstB);
                            }
                        } else {
                            if(B!=='λ') trailer = new Set([B]);
                        }
                    }
                });
            });
        }

        // Fill Table - PRIORITY FIX
        nonTerminals.forEach(lhs => {
            // Pass 1: Fill CONCRETE rules first
            grammar[lhs].forEach(rhs => {
                const firstRhs = getFirstSeq(rhs);
                firstRhs.forEach(t => {
                    if (t !== 'λ') {
                        // Always overwrite or set concrete rules
                        parseTable[lhs][t] = rhs; 
                    }
                });
            });

            // Pass 2: Fill LAMBDA rules only if slot is empty
            grammar[lhs].forEach(rhs => {
                const firstRhs = getFirstSeq(rhs);
                if (firstRhs.has('λ')) {
                    followSets[lhs].forEach(f => {
                        // CRITICAL FIX: Only set if empty. 
                        // If we have a concrete rule for 'f', don't overwrite it with lambda.
                        if (!parseTable[lhs][f]) {
                            parseTable[lhs][f] = rhs;
                        }
                    });
                }
            });
        });
    }

    function getFirstSeq(seq) {
        let res = new Set();
        let allNull = true;
        for (const sym of seq) {
            if(sym === 'λ') continue;
            if(!nonTerminals.has(sym)) {
                res.add(sym);
                allNull = false;
                break;
            }
            const f = firstSets[sym];
            f.forEach(x => { if(x!=='λ') res.add(x); });
            if(!f.has('λ')) {
                allNull = false;
                break;
            }
        }
        if(allNull) res.add('λ');
        return res;
    }

    // Compute valid lookahead based on current stack context
    function getValidLookahead(stack, fromIndex) {
        // Look at what comes BEFORE the current position in the stack (stack is LIFO)
        // So we examine stack[fromIndex-1], stack[fromIndex-2], etc.
        const continuation = [];
        for (let i = fromIndex - 1; i >= 0; i--) {
            continuation.push(stack[i]);
        }
        
        if (continuation.length === 0) {
            return new Set(); // Nothing follows
        }
        
        const firstOfContinuation = getFirstSeq(continuation);
        const result = new Set();
        
        firstOfContinuation.forEach(t => {
            if (t !== 'λ') {
                result.add(t);
            }
        });
        
        return result;
    }

    // --- 3. PARSE TRACE & TOKENIZER ---
    function runTrace(inputRaw) {
        const log = document.getElementById('logPanel');
        
        // REVERTED TOKENIZER: strictly split by spaces
        // Valid: "piece ( )"
        // Invalid: "piece()"
        const tokens = inputRaw.trim().split(/\s+/).filter(s => s !== '');
        tokens.push('$');

        let stack = ['$', startSymbol];
        let cursor = 0;
        let steps = 0;
        
        // Build parse tree
        parseTree = { symbol: startSymbol, children: [] };
        let treeStack = [parseTree];

        appendLog("STACK", "INPUT", "ACTION", false, false, true);
        appendInfo(`Grammar: ${nonTerminals.size} nonterminals, ${terminals.size} terminals`);
        appendInfo(`Input: ${tokens.length - 1} tokens`);

        while(stack.length > 0) {
            if(steps++ > 1000) { appendLog("", "", "Infinite Loop Protection", false, true); return; }

            const top = stack[stack.length - 1];
            const curr = tokens[cursor];

            // Visualization helpers
            const sView = stack.map(x => x.replace(/[<>]/g, '')).join(' ');
            const iView = tokens.slice(cursor).join(' ');

            if (top === '$') {
              if (curr === '$') {
                appendInfo(`Parsing completed successfully in ${steps} steps`);
                appendLog(sView, "", "✓ ACCEPTED", true);
              } else {
                appendLog(sView, iView, `Error: unexpected '${curr}', expected end of input`, false, true);
              }
              break;
            }

            console.log(JSON.stringify(parseTable[top], null, 4))
            console.log(curr)
            console.log("----------------")
            if (top === curr) {
              stack.pop();
              const treeNode = treeStack.pop();
              if (treeNode) {
                treeNode.symbol = curr;
                treeNode.isTerminal = true;
              }
              cursor++;
              appendLog(sView, iView, `<span class="match-highlight">✓ Match terminal '${curr}'</span>`);
            }
            else if (nonTerminals.has(top)) {
              const rule = parseTable[top]?.[curr];
              
              if (!rule) {
                const expectedArray = [...getFirstSeq(stack.reverse())].filter(t => t !== 'λ');
                console.log(stack.join(" "))
                const expectedMsg = expectedArray.length > 0 
                  ? `expected [${expectedArray.map(e => `'${e}'`).join(', ')}]`
                  : 'no valid tokens in current context';
                
                appendLog(sView, iView, `Error at ${top}: unexpected '${curr}', ${expectedMsg}`, false, true);
                break;
              }
              stack.pop();
              const currentTreeNode = treeStack.pop();
              // Push RHS reversed (excluding λ)
              if (!(rule.length === 1 && rule[0] === 'λ')) {
                for(let i=rule.length-1; i>=0; i--) {
                  stack.push(rule[i]);
                  const childNode = { symbol: rule[i], children: [] };
                  if (currentTreeNode) {
                    currentTreeNode.children.unshift(childNode);
                    treeStack.push(childNode);
                  }
                }
              } else if (currentTreeNode) {
                currentTreeNode.children.push({ symbol: 'λ', children: [], isTerminal: true });
              }
              const ruleStr = rule.length && rule[0] !== 'λ' 
                ? `Expand '${top}' → ${rule.join(' ')}` 
                : `Expand '${top}' → ε (epsilon)`;
              appendLog(sView, iView, ruleStr);
            }
            else {
              appendLog(sView, iView, `Error: unexpected '${curr}', expected '${top}'`, false, true);
              break;
            }
        }
    }
    function appendLog(s, i, a, success=false, err=false, isHeader=false) {
        const log = document.getElementById('logPanel');
        const d = document.createElement('div');
        if(isHeader) {
            d.className = 'log-header';
            d.innerHTML = `<span class="log-header-col log-stack">${s}</span>
                           <span class="log-header-col log-inp">${i}</span>
                           <span class="log-header-col log-act">${a}</span>`;
        } else {
            d.className = 'log-row';
            if(success) d.className += ' success';
            if(err) d.innerHTML = `<div class="err">${a}</div>`;
            else {
                d.innerHTML = `<span class="log-stack" title="${s}">${s}</span>
                               <span class="log-inp" title="${i}">${i}</span>
                               <span class="log-act">${a}</span>`;
            }
        }
        log.appendChild(d);
        log.scrollTop = log.scrollHeight;
    }
    
    function appendInfo(msg) {
        const log = document.getElementById('logPanel');
        const d = document.createElement('div');
        d.className = 'log-info';
        d.textContent = `ℹ ${msg}`;
        log.appendChild(d);
        log.scrollTop = log.scrollHeight;
    }

    // --- 4. VISUALIZATION ---
    function visualizeParseTree() {
        if (!parseTree || !parseTree.symbol) {
            alert('Please run the parser first!');
            return;
        }
        const root = document.getElementById('treeRoot');
        root.innerHTML = '';
        const ul = document.createElement('ul');
        ul.appendChild(createParseTreeNode(parseTree));
        root.appendChild(ul);
        resetZoom();
    }
    
    function createParseTreeNode(node) {
        const li = document.createElement('li');
        const div = document.createElement('div');
        
        const isTerminal = node.isTerminal || !nonTerminals.has(node.symbol);
        div.className = `node ${isTerminal ? 't' : 'nt'}`;
        div.textContent = node.symbol;
        li.appendChild(div);
        
        if (node.children && node.children.length > 0) {
            const ul = document.createElement('ul');
            node.children.forEach(child => {
                ul.appendChild(createParseTreeNode(child));
            });
            li.appendChild(ul);
        }
        
        return li;
    }
    
    function renderTree(rootToken) {
        const root = document.getElementById('treeRoot');
        root.innerHTML = '';
        if(!rootToken) return;
        const ul = document.createElement('ul');
        ul.appendChild(createNode(rootToken));
        root.appendChild(ul);
        resetZoom();
    }

    function createNode(token, isOpt=false) {
        const li = document.createElement('li');
        const div = document.createElement('div');
        const isNt = nonTerminals.has(token);
        
        div.className = `node ${isOpt?'opt':(isNt?'nt collapsed':'t')}`;
        div.textContent = token === 'λ' ? 'λ' : token;
        li.appendChild(div);

        if(isNt && !isOpt) {
            div.onclick = (e) => {
                e.stopPropagation();
                if(li.querySelector('ul')) {
                    li.querySelector('ul').remove();
                    div.classList.add('collapsed');
                } else {
                    expandNode(li, token);
                    div.classList.remove('collapsed');
                }
            };
        }
        return li;
    }

    function expandNode(li, token) {
        const rules = grammar[token];
        const ul = document.createElement('ul');
        if(rules.length > 1) {
            rules.forEach((r, i) => {
                const opt = createNode(`Opt ${i+1}`, true);
                const sub = document.createElement('ul');
                fillRow(r, sub);
                opt.appendChild(sub);
                ul.appendChild(opt);
            });
        } else {
            fillRow(rules[0], ul);
        }
        li.appendChild(ul);
    }
    
    function fillRow(rhs, container) {
        if(rhs.length===0 || (rhs.length===1 && rhs[0]==='λ')) {
            container.appendChild(createNode('λ'));
        } else {
            rhs.forEach(t => container.appendChild(createNode(t)));
        }
    }

    // --- 5. UTILS & MODAL ---
    function toggleTable() {
        const m = document.getElementById('tableModal');
        const c = document.getElementById('tableContent');
        if(m.style.display === 'flex') {
            m.style.display = 'none';
        } else {
            m.style.display = 'flex';
            renderTable(c);
        }
    }

    function renderTable(container) {
        let html = '<table><thead><tr><th>NT</th>';
        const termArray = Array.from(terminals).sort();
        termArray.push('$');
        termArray.forEach(t => html += `<th>${t}</th>`);
        html += '</tr></thead><tbody>';

        nonTerminals.forEach(nt => {
            html += `<tr><td>${nt}</td>`;
            termArray.forEach(t => {
                const rule = parseTable[nt][t];
                const content = rule ? (rule.length ? rule.join(' ') : 'λ') : '';
                html += `<td>${content}</td>`;
            });
            html += '</tr>';
        });
        html += '</tbody></table>';
        container.innerHTML = html;
    }

    // Sidebar Resize Logic
    const sidebar = document.getElementById('sidebar');
    const resizeHandle = document.getElementById('resizeHandle');
    let isResizing = false;
    
    resizeHandle.addEventListener('mousedown', (e) => {
        isResizing = true;
        e.preventDefault();
    });
    
    document.addEventListener('mousemove', (e) => {
        if (!isResizing) return;
        const newWidth = e.clientX;
        if (newWidth >= 300 && newWidth <= 800) {
            sidebar.style.width = newWidth + 'px';
        }
    });
    
    document.addEventListener('mouseup', () => {
        isResizing = false;
    });
    
    // Zoom Logic
    let scale=1, px=0, py=0, isDrag=false, sx, sy;
    const vp = document.getElementById('viewport');
    const st = document.getElementById('stage');
    vp.onmousedown = e => { if(e.target===vp||e.target===st){e.preventDefault(); isDrag=true; sx=e.clientX-px; sy=e.clientY-py;} };
    window.onmouseup = () => isDrag=false;
    window.onmousemove = e => { if(isDrag){ e.preventDefault(); px=e.clientX-sx; py=e.clientY-sy; st.style.transform=`translate(calc(-50% + ${px}px), ${py}px) scale(${scale})`; } };
    vp.onwheel = e => { e.preventDefault(); scale *= e.deltaY>0?0.9:1.1; st.style.transform=`translate(calc(-50% + ${px}px), ${py}px) scale(${scale})`; };
    function resetZoom() { scale=1; px=0; py=0; st.style.transform=`translate(-50%, 0) scale(1)`; }

    // Init
    window.onload = function() {
        // Restore from localStorage
        const savedCfg = localStorage.getItem('cfg_input');
        const savedTest = localStorage.getItem('test_input');
        
        if (savedCfg) {
            document.getElementById('cfgInput').value = savedCfg;
        }
        if (savedTest) {
            document.getElementById('testInput').value = savedTest;
        }
        
        runParser();
    };

</script>
</body>
</html>